<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>nndl学习笔记 第一章：绪论</title>
      <link href="/posts/1115.html"/>
      <url>/posts/1115.html</url>
      
        <content type="html"><![CDATA[<p>课程主页：<a href="https://nndl.github.io/">https://nndl.github.io/</a></p><h1 id="第一章-绪论"><a class="markdownIt-Anchor" href="#第一章-绪论"></a> 第一章 绪论</h1><ul><li><p>神经网络：一种以（人工）神经元为基本单元的模型。</p></li><li><p>深度学习：一类机器学习问题，主要解决负献度分配问题。</p></li><li><img src="https://picbed.octalzhihao.top/img/20250326153414027.png" alt="image-20250227142111089" style="zoom: 50%;" align="left"/></li></ul><h2 id="11-本书的知识体系"><a class="markdownIt-Anchor" href="#11-本书的知识体系"></a> 1.1 本书的知识体系</h2><img src="https://picbed.octalzhihao.top/img/20250326153418535.png" alt="image-20250227141850858" style="zoom:80%;" align="left"/><p><img src="https://picbed.octalzhihao.top/img/20250326153418536.png" alt="image-20250227143125590" /></p><h2 id="12-人工智能"><a class="markdownIt-Anchor" href="#12-人工智能"></a> 1.2 人工智能</h2><p>人工智能的诞生</p><blockquote><p>1956 年的达特茅斯（Dartmouth）会议：<br />在这次会议上，“人工智能”被提出并作为本研究领域的名称．同时，人工智能研究的使命也得以确定．John McCarthy提出了人工智能的定义：<strong>人工智能就是要让机器的行为看起来就像是人所表现出的智能行为一样</strong>．</p></blockquote><p>目前，人工智能的主要领域大体上可以分为以下几个方面：</p><p>（1） <strong>感知</strong>：模拟人的感知能力，对外部刺激信息（视觉和语音等）进行感知和加工．主要研究领域包括语音信息处理和计算机视觉等．</p><p>（2） <strong>学习</strong>：模拟人的学习能力，主要研究如何从样例或从与环境的交互中进行学习．主要研究领域包括监督学习、无监督学习和强化学习等．</p><p>（3） <strong>认知</strong>：模拟人的认知能力，主要研究领域包括知识表示、自然语言理解、推理、规划、决策等．</p><h3 id="人工智能的发展历史"><a class="markdownIt-Anchor" href="#人工智能的发展历史"></a> 人工智能的发展历史</h3><p>人工智能从诞生至今，经历了一次又一次的繁荣与低谷，其发展历程大体上可以分为推理期、知识期和学习期：</p><img src="https://picbed.octalzhihao.top/img/20250326153418537.png" alt="image-20250227150434590" style="zoom:80%;" align="left"/><p><strong>推理期</strong>：</p><p>1956 年达特茅斯会议之后，研究者对人工智能的热情高涨，之后的十几年是人工智能的黄金时期．大部分早期研究者都通过人类的经验，基于逻辑或者事实归纳出来一些规则，然后通过编写程序来让计算机完成一个任务。但此后，人工智能经历了一段低谷期。</p><p><strong>知识期</strong>：</p><p>到了 20 世纪 70 年代，研究者意识到知识对于人工智能系统的重要性．特别是对于一些复杂的任务，需要专家来构建知识库．在这一时期，出现了各种各样的 <strong>专家系统（Expert System）</strong>，并在特定的专业领域取得了很多成果。</p><blockquote><p>专家系统也被称为<strong>基于知识的系统</strong><br />可以简单理解为“知识库 + 推理机”，是一类具有专门知识和经验的计算机智能程序系统．<br />一个专家系统必须具备三要素：<br />1）领域专家级知识；<br />2）模拟专家思维；<br />3）达到专家级的水平．</p><p>在这一时期，Prolog（Programming in Logic）语言是主要的开发工具，用来建造专家系统、智能知识库以及处理自然语言理解等.</p></blockquote><p><strong>学习期</strong>：</p><p>机器学习开始流行：研究者开始将研究重点转向让计算机从数据中自己学习，即机器学习。<br />在人工智能领域，机器学习从一开始就是一个重要的研究方向．但直到1980年后，机器学习因其在很多领域的出色表现，才逐渐成为热门学科。</p><h3 id="人工智能的流派"><a class="markdownIt-Anchor" href="#人工智能的流派"></a> 人工智能的流派</h3><ol><li><p><strong>符号主义（Symbolism）</strong>，又称逻辑主义、心理学派或计算机学派，是指通过分析人类智能的功能，然后用计算机来实现这些功能的一类方法．</p></li><li><p><strong>连接主义（Connectionism）</strong>，又称仿生学派或生理学派，是认知科学领域中的一类信息处理的方法和理论．在认知科学领域，人类的认知过程可以看作一种信息处理过程</p></li></ol><blockquote><p>关于人工智能的流派并没有严格的划分定义，也不严格对立．有很多文献将人工智能流派分为符号主义、连接主义和行为主义三 种，其中行为主义（Actionism）主要从生物进化的角度考虑，主张从和外界环境的互动中获取智能．</p></blockquote><p><strong>符号主义方法的一个优点是可解释性，而这也正是连接主义方法的弊端．</strong></p><p>深度学习的主要模型神经网络就是一种连接主义模型．</p><p>随着深度学习的发展，越来越多的研究者开始关注如何融合符号主义和连接主义，建立一种高效并且具有可解释性的模型.</p><h2 id="13-机器学习"><a class="markdownIt-Anchor" href="#13-机器学习"></a> 1.3 机器学习</h2><p>机器学习 ≈ 构建一个映射函数（规则）</p><p>机器学习（Machine Learning，ML）是指从有限的观测数据中学习（或“猜测”）出具有一般性的规律，并利用这些规律对未知数据进行预测的方法。</p><p>传统的机器学习主要关注如何学习一个预测模型．一般需要首先将数据表示为一组特征（Feature），特征的表示形式可以是连续的数值、离散的符号或其他形式．然后将这些特征输入到预测模型，并输出预测结果．这类机器学习可以看作<strong>浅层学习（Shallow Learning）</strong>．浅层学习的一个重要特点是不涉及特征学习，其特征主要<strong>靠人工经验或特征转换方法来抽取</strong>．</p><ul><li><p>在实际任务中使用机器学习模型一般会包含以下几个步骤：</p><img src="https://picbed.octalzhihao.top/img/20250326153418538.png" style="zoom:80%;" align="left"/></li></ul><p>（1） <strong>数据预处理</strong>：对数据的原始形式进行<strong>初步的数据清理</strong>（比如去掉一些有缺失特征的样本，或去掉一些冗余的数据特征等）<strong>和加工</strong>（对数值特征进行缩放和归一化等），并<strong>构建成可用于训练机器学习模型的数据集</strong>．</p><p>（2） <strong>特征提取</strong>：从数据的原始特征中<strong>提取</strong>一些对特定机器学习任务有用的<strong>高质量特征</strong>．比如在图像分类中提取边缘、尺度不变特征变换（Scale InvariantFeature Transform，SIFT）特征，在文本分类中去除停用词等．</p><p>（3） <strong>特征转换</strong>：对特征进行进一步的加工，比如<strong>降维和升维</strong>． 很多特征转换方法也都是机器学习方法．<strong>降维包括特征抽取（Feature Extraction）和特征选择（Feature Selection）两种途径</strong>．常用的特征转换方法有<strong>主成分分析</strong>（Principal Components Analysis，PCA），<strong>线性判别分析</strong>（Linear Discriminant Analysis，LDA）等．</p><p>（4） <strong>预测</strong>：机器学习的核心部分，学习一个函数并进行预测.</p><blockquote><p>很多的机器学习问题变成了**特征工程（Feature Engineering）**问题．开发一个机器学习系统的主要工作量都消耗在了预处理、特征提取以及特征转换上．</p></blockquote><h2 id="14-表示学习"><a class="markdownIt-Anchor" href="#14-表示学习"></a> 1.4 表示学习</h2><p><strong>表示学习（Representation Learning）</strong>：可以自动地学习出有效的特征，并提高最终机器学习模型的性能。表示学习的关键是解决语义鸿沟（Semantic Gap）问题。</p><p><strong>语义鸿沟</strong>：输入数据的底层特征和高层语义信息之间的不一致性和差异性。</p><blockquote><p>如果一个预测模型直接建立在底层特征之上，会导致对预测模型的能力要求过高．如果可以有一个好的表示在某种程度上能够反映出数据的高层语义特征，那么我们就能相对容易地构建后续的机器学习模型.</p></blockquote><p>在机器学习中，我们经常使用两种方式来表示特征：<strong>局部表示</strong>（Local Representation）和<strong>分布式表示</strong>（Distributed Representation）．</p><blockquote><p>局部表示–&gt;onehot</p><p>分布式表示–&gt;分散式表示，一种语义分散到语义空间中的不同基向量上</p></blockquote><p>我们可以使用神经网络来将高维的局部表示空间<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="normal">R</mi><mrow><mi mathvariant="normal">∣</mi><mi>v</mi><mi mathvariant="normal">∣</mi></mrow></msup></mrow><annotation encoding="application/x-tex">ℝ^{|v|}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8879999999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord amsrm">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∣</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="mord mtight">∣</span></span></span></span></span></span></span></span></span></span></span></span> 映射到一个非常低维的分布式表示空间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="normal">R</mi><mi>𝐷</mi></msup></mrow><annotation encoding="application/x-tex">ℝ^𝐷</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord amsrm">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">D</span></span></span></span></span></span></span></span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐷</mi><mo>≪</mo><mi mathvariant="normal">∣</mi><mi>v</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">𝐷 ≪ |v|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≪</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord">∣</span></span></span></span>。</p><p>这个过程也称为<strong>嵌入（Embedding）</strong>。</p><p>要学习到一种好的高层语义表示（一般为分布式表示），通常需要从底层特征开始，经过多步非线性转换才能得到．深层结构的优点是可以增加特征的重用性，从而指数级地增加表示能力．因此，表示学习的关键是构建具有一定深度的多层次特征表示。</p><h2 id="15-深度学习"><a class="markdownIt-Anchor" href="#15-深度学习"></a> 1.5 深度学习</h2><img src="https://picbed.octalzhihao.top/img/20250326153418539.png" alt="image-20250228090533253" style="zoom:80%;" align="left"/><p>图1.4给出了深度学习的数据处理流程．通过多层的特征转换，把原始数据变成更高层次、更抽象的表示．这些学习到的表示可以替代人工设计的特征，从而避免“特征工程”．</p><p><strong>深度学习</strong>是将原始的数据特征通过多步的特征转换得到一种特征表示，并进一步输入到预测函数得到最终结果．和“浅层学习”不同，深度学习需要解决的关键问题是<strong>贡献度分配问题</strong>（Credit Assignment Problem，CAP）,即一个系统中不同的<strong>组件</strong>（component）或其参数对最终系统输出结果的贡献或影响.</p><blockquote><p>以下围棋为例，每当下完一盘棋，最后的结果要么赢要么输．我们会思考哪几步棋导致了最后的胜利，或者又是哪几步棋导致了最后的败局．如何判断每一步棋的贡献就是贡献度分配问题.</p></blockquote><ul><li>从某种意义上讲，深度学习可以看作一种强化学习（Reinforcement Learning，RL）.</li></ul><h3 id="贡献度分配"><a class="markdownIt-Anchor" href="#贡献度分配"></a> 贡献度分配</h3><p>贡献度分配问题（Credit Assignment Problem）是深度学习中一个核心概念，其核心在于<strong>确定神经网络中不同层、不同参数对最终输出误差的具体影响程度</strong>。</p><p>目前，深度学习采用的模型主要是神经网络模型，其主要原因是神经网络模型可以<strong>使用误差反向传播算法</strong>，从而可以比较好地<strong>解决贡献度分配问题</strong>. 只要是超过一层的神经网络都会存在贡献度分配问题。</p><blockquote><p>为何“超过一层的神经网络存在贡献度分配问题”，而单层网络不存在?</p><ul><li>单层网络因结构简单、无中间参数依赖，误差可直接映射到权重，故无贡献度分配问题；而多层网络通过反向传播的链式法则更新参数时，梯度需跨越多个非线性变换层传递，导致各层参数的贡献度需要通过动态计算分配，且易受梯度不稳定性的干扰。这一问题的存在，既是深度模型强大表示能力的代价，也是推动算法改进的核心动力。</li></ul></blockquote><h3 id="端到端学习"><a class="markdownIt-Anchor" href="#端到端学习"></a> 端到端学习</h3><p><strong>端到端学习（End-to-End Learning）</strong>，也称端到端训练，是指在学习过程中不进行分模块或分阶段训练，直接优化任务的总体目标．在端到端学习中，一般不需要明确地给出不同模块或阶段的功能，中间过程不需要人为干预．</p><p>端到端学习的训练数据为“输入-输出”对的形式，无须提供其他额外信息</p><blockquote><p>因此，端到端学习和深度学习一样，都是要解决贡献度分配问题．目前，大部分采用神经网络模型的深度学习也可以看作一种端到端的学习．</p></blockquote><h2 id="16-神经网络"><a class="markdownIt-Anchor" href="#16-神经网络"></a> 1.6 神经网络</h2><blockquote><p>神经网络天然不是深度学习，但深度学习天然是神经网络。</p></blockquote><h3 id="人工神经网络"><a class="markdownIt-Anchor" href="#人工神经网络"></a> 人工神经网络</h3><p>人工神经网络主要由大量的神经元以及它们之间的有向连接构成。搭建一个神经网络需要考虑三方面因素：</p><ul><li><strong>神经元的激活规则</strong></li></ul><p>​主要是指神经元输入到输出之间的映射关系，一般为非线性函数。</p><ul><li><strong>网络的拓扑结构</strong></li></ul><p>​不同神经元之间的连接关系。</p><ul><li><p><strong>学习算法</strong></p><p>通过训练数据来学习神经网络参数。</p></li></ul><p><strong>目前的神经网络可以分为三种类型：</strong></p><img src="https://picbed.octalzhihao.top/img/20250326153259468.png" alt="image-20250310140246489" style="zoom:50%;" align="left"/><h3 id="神经网络的发展历史"><a class="markdownIt-Anchor" href="#神经网络的发展历史"></a> <strong>神经网络的发展历史</strong></h3><p><strong>第一阶段：模型提出</strong></p><p>第一阶段为1943年~1969年，是神经网络发展的第一个高潮期。在此期间，科学家们提出了许多神经元模型和学习规则。</p><p>提出概念：MP 模型、Hebbian 法则、感知机。</p><p><strong>第二阶段：冰河期</strong></p><p>第二阶段为1969年~1983年，是神经网络发展的第一个低谷期。在此期间，神经网络的研究处于长年停滞及低潮状态。<br />反向传播算法被提出，但未被重视。<br />1980年，新知机被提出，带卷积和子采样的多层神经网络但没有反向传播。</p><p><strong>第三阶段：反向传播算法引起的复兴</strong></p><p>第三阶段为1983年~1995年，是神经网络发展的第二个高潮期.这个时期中，反向传播算法重新激发了人们对神经网络的兴趣.</p><p>用于联想记忆（Associative Memory）的神经网络，称为<strong>Hopfield网络</strong>。<br /><strong>玻尔兹曼机</strong>：就是一种随机化版本的Hopfield网络。</p><p>真正引起神经网络第二次研究高潮的是反向传播算法。</p><p>乐昆首次将反向传播算法引入了卷积神经网络，并在手写体数字识别任务上取得了巨大成果。然而<strong>梯度消失问题</strong>，成为了神经网络进一步发展的阻碍。</p><p><strong>第四阶段</strong>：<strong>流行度降低</strong>（统计机器学习方法为主流）</p><p>第四阶段为 1995 年～2006 年，在此期间，支持向量机和其他更简单的方法（例如线性分类器）在机器学习领域的流行度逐渐超过了神经网络。</p><p><strong>第五阶段</strong>：<strong>深度学习的崛起</strong></p><p>第五阶段为从 2006 年开始至今，在这一时期研究者逐渐掌握了训练深层神经网络的方法，使得神经网络重新崛起。</p><p>Hinton开启的时代：</p><img src="https://picbed.octalzhihao.top/img/20250326153418540.png" alt="image-20250326152627300" style="zoom:80%;" align=left />]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 神经网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows中PDF, TXT, Excel, Word, PPT等文件在预览窗口无法预览的解决办法(全)</title>
      <link href="/posts/16752.html"/>
      <url>/posts/16752.html</url>
      
        <content type="html"><![CDATA[<p>系统环境：Windows11</p><p>🤝 参考文章：<a href="https://blog.csdn.net/qq_58094000/article/details/144906747">https://blog.csdn.net/qq_58094000/article/details/144906747</a></p><p>⚠️<strong>注意：以上方法均会对注册表进行修改，一定要先备份整个注册表，以防万一，避免导致系统错误</strong>❗</p><h2 id="情况一显示没有预览"><a class="markdownIt-Anchor" href="#情况一显示没有预览"></a> 情况一：显示没有预览</h2><ol><li>打开文件资源管理器-文件-查看-预览窗格</li></ol><p><img src="https://picbed.octalzhihao.top/img/202503012331221.png" alt="alt text" /></p><ol start="2"><li>在文件资源管理器的右边就会显示预览窗格，此时发现Word 、Excel、 PPT等Office文件是无法正常预览的，显示没有预览。</li></ol><p><img src="https://picbed.octalzhihao.top/img/202503012331222.png" alt="alt text" /></p><h3 id="方法手动修改注册表"><a class="markdownIt-Anchor" href="#方法手动修改注册表"></a> 方法：手动修改注册表</h3><p>1.准备工作：先将所有Office相关的文件类型默认应用改为Office（之前可能被wps改为了使用wps打开），打开设置-应用-默认应用-按文件类型指定默认应用。若预览还是不能正常显示，直接进行步骤2.</p><p>2.修改与Office文件预览相关的注册表 2个项目的值，Office文件修改注册表的方式差不多，我们就以Word文件Docx为例。</p><p><strong>(1) 使用快捷键 Windows +R 运行，然后输入 “regedit” 命令，打开注册表编辑器</strong></p><p><strong>(2) 找到这一项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">计算机\HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\PreviewHandlers</span><br></pre></td></tr></table></figure><p><img src="https://picbed.octalzhihao.top/img/202503012331223.png" alt="alt text" /></p><p>（3）找到Microsoft Word previewer 这个值 对应的名称 ，把这个名称复制，作者的值是：<code>&#123;84F66100-FF7C-4fb4-B0C0-02CD7FB668FE&#125;</code></p><p><font color="red">注意一：若你的路径及数值名称和数值数据是正确的——可直接复制{84F66100-FF7C-4fb4-B0C0-02CD7FB668FE}，不用进行下面的操作。</p><p>注意二：若你的注册表的word文件类型被错误地设置为“可扩充字符串（REG_EXPAND_SZ”，需要先删除 {84F66100-FF7C-4fb4-B0C0-02CD7FB668FE} 这一项，再重新创建 {84F66100-FF7C-4fb4-B0C0-02CD7FB668FE} ，类型设置为&quot;字符串REG_SZ&quot;；修改其值为 修改其值为 Microsoft Word previewer</p><p>注意三：若你的注册表中没有找到这个项目，则按照上面的方法手工创建，另外&quot;Microsoft Word Previewer&quot;或者&quot;Microsoft Word 预览器&quot; 最好使用前面的全英文值， “Microsoft Excel Previewer&quot;或者&quot;Microsoft Excel 预览器” 也是如此。<br /></font><br /><img src="https://picbed.octalzhihao.top/img/202503012331224.png" alt="alt text" /></p><p>（4）在注册表中找到这一项 ShellEx，具体路径为<code>HKEY_CLASSES_ROOT\.docx\ShellEx\&#123;8895b1c6-b41f-4c1c-a562-0d564250836f&#125;</code>，将此处的数值数据改为上述步骤（3）里面复制的值<code>&#123;84F66100-FF7C-4fb4-B0C0-02CD7FB668FE&#125;</code>，点击确定即可。</p><p><img src="https://picbed.octalzhihao.top/img/202503012331225.png" alt="alt text" /></p><p>（5）打开文件资源管理器，再打开预览窗格，文件预览就正常了。</p><p><img src="https://picbed.octalzhihao.top/img/202503012331226.png" alt="alt text" /></p><p><strong>3.Excel 、PPT、 OUTLOOK等其它Office也是按照上述方法操作的，以下是按照上述方法操作后的结果：</strong></p><p><img src="https://picbed.octalzhihao.top/img/202503012331227.png" alt="alt text" /></p><h3 id="常用的相关的注册项名称如下"><a class="markdownIt-Anchor" href="#常用的相关的注册项名称如下"></a> 常用的相关的注册项名称如下：</h3><table><thead><tr><th>数值名称</th><th>数值数据</th></tr></thead><tbody><tr><td>{00020827-0000-0000-C000-000000000046}</td><td>Microsoft Excel previewer</td></tr><tr><td>{1531d583-8375-4d3f-b5fb-d23bbd169f22}</td><td>Windows TXT Previewer</td></tr><tr><td>{21E17C2F-AD3A-4b89-841F-09CFE02D16B7}</td><td>Microsoft Visio previewer</td></tr><tr><td>{3A84F9C2-6164-485C-A7D9-4B27F8AC009E}</td><td>Microsoft PDF Previewer</td></tr><tr><td>{65235197-874B-4A07-BDC5-E65EA825B718}</td><td>Microsoft PowerPoint previewer</td></tr><tr><td>{84F66100-FF7C-4fb4-B0C0-02CD7FB668FE}</td><td>Microsoft Word previewer</td></tr><tr><td>{DC6EFB56-9CFA-464D-8880-44885D7DC193}</td><td>Adobe PDF Preview Handler for Vista</td></tr></tbody></table><h2 id="情况二由于microsoft-word预览器中出现错误无法预览此文件"><a class="markdownIt-Anchor" href="#情况二由于microsoft-word预览器中出现错误无法预览此文件"></a> 情况二：由于Microsoft Word预览器中出现错误，无法预览此文件。</h2><p>具体如下图所示：</p><p><img src="https://picbed.octalzhihao.top/img/202503012331228.png" alt="alt text" /></p><p>产生原因是由于该文件是从互联网上获取的，Windows自动开启了保护视图，导致无法预览。</p><p>与此同时，打开这种文件也一般会如下图所示：</p><p><img src="https://picbed.octalzhihao.top/img/202503012331229.png" alt="alt text" /></p><p>这样只要**“启用编辑”后保存**，就不再是受保护视图了。</p><p>然后就可以正常在预览窗口预览了。</p><p>除此之外，也可以右键-属性，勾选<code>解除锁定</code>，应用。用此方法也可以解除受保护视图。</p><p><img src="https://picbed.octalzhihao.top/img/202503012331230.png" alt="alt text" /></p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows系统问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【手册】NLP词性标注对照表</title>
      <link href="/posts/55593.html"/>
      <url>/posts/55593.html</url>
      
        <content type="html"><![CDATA[<h2 id="jieba词性对照表北大词性标注集"><a class="markdownIt-Anchor" href="#jieba词性对照表北大词性标注集"></a> jieba词性对照表（北大词性标注集）</h2><table><thead><tr><th style="text-align:center">标签</th><th style="text-align:center">含义</th><th style="text-align:center">标签</th><th style="text-align:center">含义</th><th style="text-align:center">标签</th><th style="text-align:center">含义</th><th style="text-align:center">标签</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">a</td><td style="text-align:center">形容词</td><td style="text-align:center">ad</td><td style="text-align:center">副形词</td><td style="text-align:center">ag</td><td style="text-align:center">形容词性语素</td><td style="text-align:center">an</td><td style="text-align:center">名形词</td></tr><tr><td style="text-align:center">b</td><td style="text-align:center">区别词</td><td style="text-align:center">c</td><td style="text-align:center">连词</td><td style="text-align:center">d</td><td style="text-align:center">副词</td><td style="text-align:center">df</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">e</td><td style="text-align:center">叹词</td><td style="text-align:center">f</td><td style="text-align:center">方位词</td><td style="text-align:center">g</td><td style="text-align:center">语素</td><td style="text-align:center">h</td><td style="text-align:center">前接成分</td></tr><tr><td style="text-align:center">i</td><td style="text-align:center">成语</td><td style="text-align:center">j</td><td style="text-align:center">简称略称</td><td style="text-align:center">k</td><td style="text-align:center">后接成分</td><td style="text-align:center">l</td><td style="text-align:center">习用语</td></tr><tr><td style="text-align:center">m</td><td style="text-align:center">数词</td><td style="text-align:center">mg</td><td style="text-align:center"></td><td style="text-align:center">mq</td><td style="text-align:center">数量词</td><td style="text-align:center">n</td><td style="text-align:center">名词</td></tr><tr><td style="text-align:center">ng</td><td style="text-align:center">名词性语素</td><td style="text-align:center">nr</td><td style="text-align:center">人名</td><td style="text-align:center">nrfg</td><td style="text-align:center"></td><td style="text-align:center">nrt</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">ns</td><td style="text-align:center">地名</td><td style="text-align:center">nt</td><td style="text-align:center">机构团体名</td><td style="text-align:center">nz</td><td style="text-align:center">其他专名</td><td style="text-align:center">o</td><td style="text-align:center">拟声词</td></tr><tr><td style="text-align:center">p</td><td style="text-align:center">介词</td><td style="text-align:center">q</td><td style="text-align:center">量词</td><td style="text-align:center">r</td><td style="text-align:center">代词</td><td style="text-align:center">rg</td><td style="text-align:center">代词性语素</td></tr><tr><td style="text-align:center">rr</td><td style="text-align:center">人称代词</td><td style="text-align:center">rz</td><td style="text-align:center">指示代词</td><td style="text-align:center">s</td><td style="text-align:center">处所词</td><td style="text-align:center">t</td><td style="text-align:center">时间词</td></tr><tr><td style="text-align:center">tg</td><td style="text-align:center">时语素</td><td style="text-align:center">u</td><td style="text-align:center">助词</td><td style="text-align:center">ud</td><td style="text-align:center">结构助词 得</td><td style="text-align:center">ug</td><td style="text-align:center">时态助词</td></tr><tr><td style="text-align:center">uj</td><td style="text-align:center">结构助词 的</td><td style="text-align:center">ul</td><td style="text-align:center">时态助词 了</td><td style="text-align:center">uv</td><td style="text-align:center">结构助词 地</td><td style="text-align:center">uz</td><td style="text-align:center">时态助词 着</td></tr><tr><td style="text-align:center">v</td><td style="text-align:center">动词</td><td style="text-align:center">vd</td><td style="text-align:center">副动词</td><td style="text-align:center">vg</td><td style="text-align:center">动词性语素</td><td style="text-align:center">vi</td><td style="text-align:center">不及物动词</td></tr><tr><td style="text-align:center">vn</td><td style="text-align:center">名动词</td><td style="text-align:center">vq</td><td style="text-align:center"></td><td style="text-align:center">x</td><td style="text-align:center">非语素词</td><td style="text-align:center">y</td><td style="text-align:center">语气词</td></tr><tr><td style="text-align:center">z</td><td style="text-align:center">状态词</td><td style="text-align:center">zg</td><td style="text-align:center"></td><td style="text-align:center">eng</td><td style="text-align:center">英文</td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><h2 id="ltp词性对照表863词性标注集"><a class="markdownIt-Anchor" href="#ltp词性对照表863词性标注集"></a> LTP词性对照表（863词性标注集）</h2><table><thead><tr><th style="text-align:center">Tag</th><th style="text-align:center">Description</th><th style="text-align:center">Example</th><th style="text-align:center">Tag</th><th style="text-align:center">Description</th><th style="text-align:center">Example</th></tr></thead><tbody><tr><td style="text-align:center">a</td><td style="text-align:center">adjective</td><td style="text-align:center">美丽</td><td style="text-align:center">ni</td><td style="text-align:center">organization name</td><td style="text-align:center">保险公司</td></tr><tr><td style="text-align:center">b</td><td style="text-align:center">other noun-modifier</td><td style="text-align:center">大型, 西式</td><td style="text-align:center">nl</td><td style="text-align:center">location noun</td><td style="text-align:center">城郊</td></tr><tr><td style="text-align:center">c</td><td style="text-align:center">conjunction</td><td style="text-align:center">和, 虽然</td><td style="text-align:center">ns</td><td style="text-align:center">geographical name</td><td style="text-align:center">北京</td></tr><tr><td style="text-align:center">d</td><td style="text-align:center">adverb</td><td style="text-align:center">很</td><td style="text-align:center">nt</td><td style="text-align:center">temporal noun</td><td style="text-align:center">近日, 明代</td></tr><tr><td style="text-align:center">e</td><td style="text-align:center">exclamation</td><td style="text-align:center">哎</td><td style="text-align:center">nz</td><td style="text-align:center">other proper noun</td><td style="text-align:center">诺贝尔奖</td></tr><tr><td style="text-align:center">g</td><td style="text-align:center">morpheme</td><td style="text-align:center">茨, 甥</td><td style="text-align:center">o</td><td style="text-align:center">onomatopoeia</td><td style="text-align:center">哗啦</td></tr><tr><td style="text-align:center">h</td><td style="text-align:center">prefix</td><td style="text-align:center">阿, 伪</td><td style="text-align:center">p</td><td style="text-align:center">preposition</td><td style="text-align:center">在, 把</td></tr><tr><td style="text-align:center">i</td><td style="text-align:center">idiom</td><td style="text-align:center">百花齐放</td><td style="text-align:center">q</td><td style="text-align:center">quantity</td><td style="text-align:center">个</td></tr><tr><td style="text-align:center">j</td><td style="text-align:center">abbreviation</td><td style="text-align:center">公检法</td><td style="text-align:center">r</td><td style="text-align:center">pronoun</td><td style="text-align:center">我们</td></tr><tr><td style="text-align:center">k</td><td style="text-align:center">suffix</td><td style="text-align:center">界, 率</td><td style="text-align:center">u</td><td style="text-align:center">auxiliary</td><td style="text-align:center">的, 地</td></tr><tr><td style="text-align:center">m</td><td style="text-align:center">number</td><td style="text-align:center">一, 第一</td><td style="text-align:center">v</td><td style="text-align:center">verb</td><td style="text-align:center">跑, 学习</td></tr><tr><td style="text-align:center">n</td><td style="text-align:center">general noun</td><td style="text-align:center">苹果</td><td style="text-align:center">wp</td><td style="text-align:center">punctuation</td><td style="text-align:center">，。！</td></tr><tr><td style="text-align:center">nd</td><td style="text-align:center">direction noun</td><td style="text-align:center">右侧</td><td style="text-align:center">ws</td><td style="text-align:center">foreign words</td><td style="text-align:center">CPU</td></tr><tr><td style="text-align:center">nh</td><td style="text-align:center">person name</td><td style="text-align:center">杜甫, 汤姆</td><td style="text-align:center">x</td><td style="text-align:center">non-lexeme</td><td style="text-align:center">萄, 翱</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">z</td><td style="text-align:center">descriptive words</td><td style="text-align:center">瑟瑟，匆匆</td></tr></tbody></table><p>中文翻译版</p><table><thead><tr><th style="text-align:center">Tag</th><th style="text-align:center">Description</th><th style="text-align:center">Description-zh</th><th style="text-align:center">Tag</th><th style="text-align:center">Description</th><th style="text-align:center">Description-zh</th></tr></thead><tbody><tr><td style="text-align:center">a</td><td style="text-align:center">adjective</td><td style="text-align:center">形容词</td><td style="text-align:center">ni</td><td style="text-align:center">organization name</td><td style="text-align:center">机构名</td></tr><tr><td style="text-align:center">b</td><td style="text-align:center">other noun-modifier</td><td style="text-align:center">其他名词修饰词</td><td style="text-align:center">nl</td><td style="text-align:center">location noun</td><td style="text-align:center">位置名词</td></tr><tr><td style="text-align:center">c</td><td style="text-align:center">conjunction</td><td style="text-align:center">连词</td><td style="text-align:center">ns</td><td style="text-align:center">geographical name</td><td style="text-align:center">地点名词</td></tr><tr><td style="text-align:center">d</td><td style="text-align:center">adverb</td><td style="text-align:center">副词</td><td style="text-align:center">nt</td><td style="text-align:center">temporal noun</td><td style="text-align:center">时间名词</td></tr><tr><td style="text-align:center">e</td><td style="text-align:center">exclamation</td><td style="text-align:center">叹词</td><td style="text-align:center">nz</td><td style="text-align:center">other proper noun</td><td style="text-align:center">其他专有名词</td></tr><tr><td style="text-align:center">g</td><td style="text-align:center">morpheme</td><td style="text-align:center">语素</td><td style="text-align:center">o</td><td style="text-align:center">onomatopoeia</td><td style="text-align:center">拟声词</td></tr><tr><td style="text-align:center">h</td><td style="text-align:center">prefix</td><td style="text-align:center">前缀</td><td style="text-align:center">p</td><td style="text-align:center">preposition</td><td style="text-align:center">介词，前置词</td></tr><tr><td style="text-align:center">i</td><td style="text-align:center">idiom</td><td style="text-align:center">成语、习语</td><td style="text-align:center">q</td><td style="text-align:center">quantity</td><td style="text-align:center">量词</td></tr><tr><td style="text-align:center">j</td><td style="text-align:center">abbreviation</td><td style="text-align:center">缩写</td><td style="text-align:center">r</td><td style="text-align:center">pronoun</td><td style="text-align:center">代词</td></tr><tr><td style="text-align:center">k</td><td style="text-align:center">suffix</td><td style="text-align:center">后缀</td><td style="text-align:center">u</td><td style="text-align:center">auxiliary</td><td style="text-align:center">助词</td></tr><tr><td style="text-align:center">m</td><td style="text-align:center">number</td><td style="text-align:center">数字</td><td style="text-align:center">v</td><td style="text-align:center">verb</td><td style="text-align:center">动词</td></tr><tr><td style="text-align:center">n</td><td style="text-align:center">general noun</td><td style="text-align:center">一般名词</td><td style="text-align:center">wp</td><td style="text-align:center">punctuation</td><td style="text-align:center">标点</td></tr><tr><td style="text-align:center">nd</td><td style="text-align:center">direction noun</td><td style="text-align:center">方位名词</td><td style="text-align:center">ws</td><td style="text-align:center">foreign words</td><td style="text-align:center">外文词</td></tr><tr><td style="text-align:center">nh</td><td style="text-align:center">person name</td><td style="text-align:center">人名</td><td style="text-align:center">x</td><td style="text-align:center">non-lexeme</td><td style="text-align:center">非词根</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">z</td><td style="text-align:center">descriptive words</td><td style="text-align:center">瑟瑟，匆匆</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 自然语言处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024年云南大学迎新杯程序设计大赛の题解</title>
      <link href="/posts/61220.html"/>
      <url>/posts/61220.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>本场比赛出题周期里，由于在备赛冲击奖牌，就把这场第二届迎新杯的出题工作基本全交给校队未来的栋梁们了。整个出题过程中，几位学弟们认真负责的态度让我非常放心，事实证明也确实带来了一套不错的题👍从去年叱咤赛场的选手身份转变为尽职尽责的出题人，他们做得很棒！<br />这场出题人比去年还是很善良的（），赛前不断地在降难度。（而且原本Lihg给的两个疑似蓝题+紫题都被ban了<br />最难的应该算是天际线那道题，思维上有一定的门槛，但也不难想。我勉强算出了这一道题，目的就是想给赛有余力oier们强调一下STL的重要性。<br />应该说，善良的出题人这回是没有防AK的，其实都是可做题。<br />非要细分的话，我赛前预估大概4 3 2的梯度（4签到+3简单+2中等，octal的个人看法）</p><table><thead><tr><th style="text-align:center">题号</th><th style="text-align:center">预估难度</th><th style="text-align:center">知识点</th><th style="text-align:center">FirstBlood</th></tr></thead><tbody><tr><td style="text-align:center">A</td><td style="text-align:center">1 ★</td><td style="text-align:center">简单数学、容斥原理</td><td style="text-align:center"><strong>ェメ</strong></td></tr><tr><td style="text-align:center">B</td><td style="text-align:center">2 ★</td><td style="text-align:center">二分、数学</td><td style="text-align:center"><strong>clhdlg</strong></td></tr><tr><td style="text-align:center">C</td><td style="text-align:center">2 ★</td><td style="text-align:center">DP动态规划</td><td style="text-align:center"><strong>Ovine</strong></td></tr><tr><td style="text-align:center">D</td><td style="text-align:center">3 ★</td><td style="text-align:center">贪心、优先队列</td><td style="text-align:center">/</td></tr><tr><td style="text-align:center">E</td><td style="text-align:center">2 ★</td><td style="text-align:center">贪心</td><td style="text-align:center"><strong>ェメ</strong></td></tr><tr><td style="text-align:center">F</td><td style="text-align:center">1 ★</td><td style="text-align:center">思维题</td><td style="text-align:center"><strong>翊，</strong></td></tr><tr><td style="text-align:center">G</td><td style="text-align:center">1 ★</td><td style="text-align:center">贪心、简单模拟</td><td style="text-align:center"><strong>翊，</strong></td></tr><tr><td style="text-align:center">H</td><td style="text-align:center">1 ★（签到题）</td><td style="text-align:center">简单数学</td><td style="text-align:center"><strong>learner_164</strong></td></tr><tr><td style="text-align:center">I</td><td style="text-align:center">3 ★</td><td style="text-align:center">组合数学、推式子<br />打表找规律</td><td style="text-align:center"><strong>翊，</strong></td></tr></tbody></table><p>赛后看了一下，虽然简单了，但也是有区分度的，各个水平的选手也都有题可做，为出题人们点赞！👍<br />另外预告一下：<br />下学期的校赛将会由YNU现役单体最强、刷题量3000+的Lihg主导出题，大家敬请期待一下！</p><hr /><blockquote><p>说明：以下所有题解代码，大家关注main函数就行了，代码头部纯属个人习惯，不用深究。</p></blockquote><h2 id="a-穿越之爆裂魔法与特殊数字"><a class="markdownIt-Anchor" href="#a-穿越之爆裂魔法与特殊数字"></a> A 穿越之爆裂魔法与特殊数字</h2><p>【容斥原理】</p><p>首先，我想对于刚高考完的同学来说，<code>整除</code> 这个概念可能有点陌生了。因为大家第一次接触这个词应该是小学初中，高考数学应该是不涉及。<br />不过大家看样例解释应该就能get到：</p><blockquote><p>a 被 b 整除 &lt;=&gt; a 除 b 余数为0 &lt;=&gt; a 是 b 的倍数</p></blockquote><p>这道题就是相当于求 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>−</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1-n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 中，有多少个数是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">a, b, c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">c</span></span></span></span> 中至少一个数的倍数。<br />如果是求 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>−</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1-n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span> 的倍数，要怎么求？<br />是不是只需要 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">n / x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord">/</span><span class="mord mathnormal">x</span></span></span></span> (整除) 就行。<br />那是不是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mi>a</mi><mo>+</mo><mi>n</mi><mi mathvariant="normal">/</mi><mi>b</mi><mo>+</mo><mi>n</mi><mi mathvariant="normal">/</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">n / a + n / b + n / c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord">/</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord">/</span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord">/</span><span class="mord mathnormal">c</span></span></span></span> ？<br />no，no，no。因为会有重复的。<br />所以就需要用到容斥原理，看张图就理解了<br /><img src="https://picbed.octalzhihao.top/img/202412061648830.png" alt="image-20241206164835518" /><br />代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pdd pair<span class="string">&lt;double, double&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pll pair<span class="string">&lt;ll, ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, a, b, c;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    res += n/a + n/b + n/c;</span><br><span class="line">    res -= n/(a*b) + n/(a*c) + n/(b*c);</span><br><span class="line">    res += n / (a*b*c);</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">10</span>);</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t --)</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="b-机房的神秘灯光"><a class="markdownIt-Anchor" href="#b-机房的神秘灯光"></a> B 机房的神秘灯光</h2><p>【二分】<br />其实有经验的选手这道题就是会比较秒杀，因为二分的题基本都比较套路。<br /><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 的范围是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi>e</mi><mn>18</mn></mrow><annotation encoding="application/x-tex">1e18</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord mathnormal">e</span><span class="mord">1</span><span class="mord">8</span></span></span></span> ，这也不像是有规律的数学模型，所以第一反应就应该想到二分。<br />要讲清楚这道题，大概有两个要点：<br />① 第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 盏灯只会被 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 的因数改变状态。（并且 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 的因数是小于等于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 的，即一定都会被选择）<br />② 按奇数次开关，灯关；按偶数次开关，灯才会依然开。<br />③ 只有平方数的因子个数是奇数，其他数的因子一定是两两不相同的数一组。<br />那么，实际上就是求满足 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1, n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">]</span></span></span></span> 中非平方数的个数恰好为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 的最小的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是多少。考虑到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 范围是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi>e</mi><mn>18</mn></mrow><annotation encoding="application/x-tex">1e18</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord mathnormal">e</span><span class="mord">1</span><span class="mord">8</span></span></span></span> 二分求解即可，复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log_2{k})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span><span class="mclose">)</span></span></span></span>，大概在64这个数量级。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pdd pair<span class="string">&lt;double, double&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pll pair<span class="string">&lt;ll, ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll k;</span><br><span class="line">    cin &gt;&gt; k;</span><br><span class="line">    <span class="comment">// check函数，个人习惯使用的是Lambda表达式，其实就理解为函数就行</span></span><br><span class="line">    <span class="keyword">auto</span> check = [&amp;](ll x) &#123;</span><br><span class="line">        ll t = <span class="built_in">sqrt</span>(x);</span><br><span class="line">        <span class="keyword">return</span> x - t &gt;= k;</span><br><span class="line">    &#125;;</span><br><span class="line">    ll l = <span class="number">1</span>, r = <span class="number">4e18</span>; <span class="comment">// long long最大大概4e18，不如开大点</span></span><br><span class="line">    <span class="comment">// 二分找一个满足条件的最小值</span></span><br><span class="line">    <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">        ll mid = l+r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; l &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">10</span>);</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t --)</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="c-云山探险记2"><a class="markdownIt-Anchor" href="#c-云山探险记2"></a> C 云山探险记2</h2><p>【DP】</p><blockquote><p>前言：去年校赛的云山探险记1也是一个比较典的DP，不过思维难度比本题高一些，欢迎有兴趣的同学去钻研一下（PS：去年那题的定位是防AK，所以一时半会儿没想通也别着急）。</p></blockquote><p>题意就是有一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 个数的序列，每个数可以选或不选。<br />选到第偶数个数时，可以收获翻倍。问选完n个数后，最大收获是多少。</p><p>这道题之所以不能直接贪心，是因为我中途可以放弃选一个数，从而使得后续有个原本是第奇数个选中的数，变为第偶数个数，这个数很大的话<code>收获翻倍</code>就能弥补放弃的损失。</p><p>还有个值得注意的点是，不会有连续的两个数都不被选中。（从贪心的角度上，这个行为是自损而无利的）</p><h3 id="dp思路一"><a class="markdownIt-Anchor" href="#dp思路一"></a> DP思路一</h3><p>解析直接看代码里的注释</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pdd pair<span class="string">&lt;double, double&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pll pair<span class="string">&lt;ll, ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;vector&lt;ll&gt;&gt; <span class="built_in">dp</span>(n<span class="number">+5</span>, <span class="built_in">vector</span>&lt;ll&gt;(<span class="number">2</span>));</span><br><span class="line">    <span class="comment">// dp[i][0] 选了第i位后有偶数个数时的最大收获</span></span><br><span class="line">    <span class="comment">// dp[i][1] 选了第i位后有奇数个数时的最大收获</span></span><br><span class="line">    <span class="comment">// 由于第n个数不选不会有任何好处，那最优解肯定是必选第n个数的</span></span><br><span class="line">    <span class="comment">// 所以答案是max(dp[n][0], dp[n][1])</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n<span class="number">+1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">1</span>] = a[<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">-2e18</span>; <span class="comment">//选了第1位后就只能是奇数个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>] + a[i]*<span class="number">2</span>, dp[i<span class="number">-2</span>][<span class="number">1</span>] + a[i]*<span class="number">2</span>); <span class="comment">// 分别对应选i-1和不选i-1</span></span><br><span class="line">        dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>] + a[i], dp[i<span class="number">-2</span>][<span class="number">0</span>] + a[i]); <span class="comment">// 分别对应选i-1和不选i-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第n位是必选的，前n-1位选与不选的状态递推过来，一定是没有疏漏的</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">max</span>(dp[n][<span class="number">0</span>], dp[n][<span class="number">1</span>]) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dp思路二"><a class="markdownIt-Anchor" href="#dp思路二"></a> DP思路二</h3><p>解析直接看代码里的注释</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;vector&lt;ll&gt;&gt; <span class="built_in">dp</span>(n<span class="number">+5</span>, <span class="built_in">vector</span>&lt;ll&gt;(<span class="number">2</span>));</span><br><span class="line">    <span class="comment">// dp[i][0] 走到第i位为止，选了偶数个数时的最大收获（第i位不一定选）</span></span><br><span class="line">    <span class="comment">// dp[i][1] 走到第i位为止，选了奇数个数时的最大收获（第i位不一定选）</span></span><br><span class="line">    <span class="comment">// 最终选到的数的个数要么是奇数要么是偶数</span></span><br><span class="line">    <span class="comment">// 所以答案是max(dp[n][0], dp[n][1])</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n<span class="number">+1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">1</span>] = a[<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">-2e18</span>; <span class="comment">// 选了第1位后就只能是奇数个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        <span class="comment">// 分别对应选与不选第i位</span></span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>] + a[i]*<span class="number">2</span>);</span><br><span class="line">        dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">0</span>] + a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">max</span>(dp[n][<span class="number">0</span>], dp[n][<span class="number">1</span>]) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="d-穿越之我在都市天际线里修路"><a class="markdownIt-Anchor" href="#d-穿越之我在都市天际线里修路"></a> D 穿越之我在《都市：天际线》里修路</h2><p>【贪心】【优先队列】<br />前段时间看朋友在玩这个游戏，顺手想了个故事。<br />抛开题目背景，一句话题意其实就是：<br />有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 个点，每个点有一个权值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ，每个点的度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">d_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 。构造一颗树使得 $ \sum_{i=1}^N a_i\times{d_i}^2$ 的值最小。</p><blockquote><p>不知道有没有同学看到这道题的时候，想到了最小生成树🤔<br />这道题的思想和最小生成树的prim算法很类似哈。<br />不过只能说学过prim有助于想到正解，其实完全不会prim也是能写的哈。prim算法虽然有名有姓的，但也就是个贪心而已，没那么厉害。</p></blockquote><p>这道题怎么贪呢？<br />如果一上来就从整体（完全体的树）考虑，根本无从下手。<br />我们不妨不要那么聪明，别一上来就建模成 &quot;构造一颗树使得 $ \sum_{i=1}^N a_i\times{d_i}^2$ 的值最小“这个问题哈。<br />不如顺着题目描述，路是一条一条修的，我们就一步步考虑。<br />我们考虑一个一个城市地扩张连通块，直到全部城市都连进来。<br />对于题给背景，每修一条路其实就对应着把一个新城市连到当前的连通块里。（一定是这样的，因为是树）<br />那么新增的城市 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 当前只会连着一条公路，即加进来的代价为 $a_i × 1 $ ，是个固定值。<br />而与城市 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 所连接的那个点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> 所新增的代价是不固定的，这也就是我们要贪的对象。<br />原本 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> 的代价是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>j</mi></msub><mo>×</mo><msubsup><mi>d</mi><mi>j</mi><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex">a_j × d_j^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8694379999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.20888em;vertical-align:-0.394772em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.441336em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.394772em;"><span></span></span></span></span></span></span></span></span></span> ，现在要变为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>j</mi></msub><mo>×</mo><mo stretchy="false">(</mo><msub><mi>d</mi><mi>j</mi></msub><mo>+</mo><mn>1</mn><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">a_j × (d_j+1)^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8694379999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>。<br />我们要最小化总的代价，其实只需要最小化每一步的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>j</mi></msub><mo>×</mo><mo stretchy="false">(</mo><msub><mi>d</mi><mi>j</mi></msub><mo>+</mo><mn>1</mn><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo>−</mo><msub><mi>a</mi><mi>j</mi></msub><mo>×</mo><msubsup><mi>d</mi><mi>j</mi><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex">a_j × (d_j+1)^2 - a_j × d_j^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8694379999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8694379999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.20888em;vertical-align:-0.394772em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.441336em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.394772em;"><span></span></span></span></span></span></span></span></span></span>。<br />至于怎么维护每个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> 对应的代价，可能需要用到优先队列 + 重载运算符。（不重载的话也能写，就是麻烦点）<br />关于重载运算符的方法，可以看一下我以前写过的这篇文章：<a href="https://www.cnblogs.com/zhouzhihao/p/10974594.html">优先队列的重载运算符 - octal_zhihao - 博客园</a><br />代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pdd pair<span class="string">&lt;double, double&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pll pair<span class="string">&lt;ll, ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    ll x;</span><br><span class="line">    ll y;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(node a,node b) &#123;</span><br><span class="line">        ll ta = a.x * ((a.y<span class="number">+1</span>)*(a.y<span class="number">+1</span>) - a.y*a.y);</span><br><span class="line">        ll tb = b.x * ((b.y<span class="number">+1</span>)*(b.y<span class="number">+1</span>) - b.y*b.y);</span><br><span class="line">        <span class="keyword">return</span> ta &gt; tb;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;node&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">a</span><span class="params">(n<span class="number">+1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>()<span class="number">+1</span>, a.<span class="built_in">end</span>());</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;a[<span class="number">1</span>], <span class="number">1</span>&#125;);</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;a[<span class="number">2</span>], <span class="number">1</span>&#125;);</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    res += a[<span class="number">1</span>] + a[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        <span class="keyword">auto</span> [w, d] = q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        res += w * ((d<span class="number">+1</span>)*(d<span class="number">+1</span>) - d*d);</span><br><span class="line">        res += a[i];</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;a[i], <span class="number">1</span>&#125;);</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;w, d<span class="number">+1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">10</span>);</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="e-饥饿之墙"><a class="markdownIt-Anchor" href="#e-饥饿之墙"></a> E 饥饿之墙</h2><p>【贪心】<br />贪心策略：每次摧毁从最左边的尚未被破坏的墙的右端点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">R_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 开始破坏，就能保证每次摧毁的D列尽可能得靠右，也就能尽可能多地覆盖右侧的墙。<br />换句话说，每次在未摧毁的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>L</mi><mo separator="true">,</mo><mi>R</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(L, R)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">L</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mclose">)</span></span></span></span> 对中找 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> 最小的来打。<br />那么只需要，最开始就按 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> 来排序，然后从前往后遍历就行。<br />代码如下，详细过程可看注释：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pdd pair<span class="string">&lt;double, double&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pll pair<span class="string">&lt;ll, ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, d;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; d;</span><br><span class="line">    vector&lt;pii&gt; a;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        a.<span class="built_in">push_back</span>(&#123;l, r&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据右边界从小到大排序</span></span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), [&amp;](pii x, pii y) &#123;</span><br><span class="line">        <span class="keyword">return</span> x.second &lt; y.second;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">int</span> R = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// R代表当前拳头已经覆盖区域的最右边的位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> [l, r]: a) &#123;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= R) <span class="keyword">continue</span>; <span class="comment">// l&lt;=R 意味着已经被打倒了</span></span><br><span class="line">        <span class="comment">// 否则就是没被打倒</span></span><br><span class="line">        <span class="comment">// 那么此时的r就是我们要选的未摧毁的墙里最小的r</span></span><br><span class="line">        res ++; <span class="comment">// 从r开始打一拳！</span></span><br><span class="line">        R = r + d - <span class="number">1</span>; <span class="comment">// 当前覆盖区域扩展到r后面d位 </span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">10</span>);</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="f-fire_lime的3-or-2问题"><a class="markdownIt-Anchor" href="#f-fire_lime的3-or-2问题"></a> F Fire_Lime的*3 or /2问题</h2><p>【思维】【数学】<br />这种题其实也算初阶的诈骗题，ICPC其实还有很多很智慧的诈骗题（也非常有意思）。</p><p>过程搞这么复杂，其实*3是不会增加因数分解后2的个数的。<br />所以我们只需要求出，这些数里一共有多少个因子2可以来除就ok了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pdd pair<span class="string">&lt;double, double&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pll pair<span class="string">&lt;ll, ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        cin &gt;&gt; a;</span><br><span class="line">        <span class="keyword">while</span>(a % <span class="number">2</span> == <span class="number">0</span>) &#123; <span class="comment">// 还有因数2就除</span></span><br><span class="line">            a /= <span class="number">2</span>;</span><br><span class="line">            res ++;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="g-fire_lime的打印机"><a class="markdownIt-Anchor" href="#g-fire_lime的打印机"></a> G Fire_Lime的打印机</h2><p>【贪心】【模拟】<br />验题的时候目测G的做法应该是比较多的，但本质其实差不多。我也没考虑其他做法，这里就给一种好理解的做法吧：<br />首先，我们想<strong>尽可能地省时</strong>，那就要尽可能<strong>最大化每次右移所打印的数</strong>。</p><p>然后规则上，打印机打印了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span></span></span></span> ，那么下一次就只能打印 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">a + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，都没有其他方案可选。那其实最大化每次打印的方案是显然且固定的，就是<strong>每次遇到上一个数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">+</span><span class="mord">1</span></span></span></span> 就打印</strong>，直到无数可印而返回。</p><blockquote><p>这里有个误区就是考虑到DP，但其实每次转移只能到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">a+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> ，转移结果是固定的，没必要DP。<br />拓展：这题再加点难度可以改为：“每次打印能打印比上一个数字更大的数”，例如打印出数字 &quot;1&quot;之后，可以打印2,3,4…,n。<br />这样就是一道家喻户晓的经典DP模型了。</p></blockquote><p>那么回过来，这个逻辑用代码要怎么实现呢？<br />对于一个数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span></span></span></span> 而言，只要 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">a - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 在前面出现过，我们在 打印 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">a - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的那一轮就可以把 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span></span></span></span> 打印了，不需要付出额外的代价。反之，就只能新开一轮，从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span></span></span></span> 开始打印。</p><p>怎么记录 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">a-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 是否在 $ a $ 之前呢？一个简单的做法是用 <code>STL</code> 库的 set 容器（不用万能头的话，需要引入set头文件）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pdd pair<span class="string">&lt;double, double&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pll pair<span class="string">&lt;ll, ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> ai;</span><br><span class="line">        cin &gt;&gt; ai;</span><br><span class="line">        <span class="keyword">if</span>(!st.<span class="built_in">count</span>(ai<span class="number">-1</span>)) res ++;</span><br><span class="line">        st.<span class="built_in">insert</span>(ai);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res<span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不用set其实也很简单，用一个bool类型的数组代替就行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">p</span><span class="params">(n<span class="number">+1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> ai;</span><br><span class="line">        cin &gt;&gt; ai;</span><br><span class="line">        <span class="keyword">if</span>(!p[ai<span class="number">-1</span>]) res ++;</span><br><span class="line">        p[ai] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res<span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="h-我爱ynu-icpc校队"><a class="markdownIt-Anchor" href="#h-我爱ynu-icpc校队"></a> H 我爱YNU-ICPC校队</h2><p>【签到】【模拟】or【数学】<br />这道题的难点其实就在于有隔天的，如果要比大小，那应该统一参考系。<br />做法很多哈，为了保证正确性其实可以多写几个if来模拟一下时间。花点时间总能做出来的，所以定位是签到。<br />介绍一下我的做法：<br />首先需要明确一点，对一个时间+24是不会改变它本来的意义的。<br />我们不妨就把 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span> 作为最早的时间，凡是比b小的都加24.<br />然后看看 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span></span></span></span> 是否在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>b</mi><mo separator="true">,</mo><mi>c</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[b, c]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">c</span><span class="mclose">]</span></span></span></span> 范围内即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">    <span class="keyword">if</span>(c &lt; b) c += <span class="number">24</span>;</span><br><span class="line">    <span class="keyword">if</span>(a &lt; b) a += <span class="number">24</span>;</span><br><span class="line">    <span class="keyword">if</span>(a &gt;= b &amp;&amp; a &lt;= c) cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;I love YNU-ICPC team&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="i-量子宇宙的迎新赛"><a class="markdownIt-Anchor" href="#i-量子宇宙的迎新赛"></a> I 量子宇宙的迎新赛</h2><p>【组合数学】【推式子】</p><p>考了考高中数学的知识，数竞生应该是能拿捏的<br />从高中课本上有的两个公式入手<br />性质1: $ C_{n}^{m} =\frac{n!}{m!(n-m)!} $</p><p>性质2: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>C</mi><mi>n</mi><mn>1</mn></msubsup><mo>+</mo><msubsup><mi>C</mi><mi>n</mi><mn>2</mn></msubsup><mo>+</mo><msubsup><mi>C</mi><mi>n</mi><mn>3</mn></msubsup><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><msubsup><mi>C</mi><mi>n</mi><mi>n</mi></msubsup><mo>=</mo><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">C_{n}^{1}+C_{n}^{2}+ C_{n}^{3}+ ... +C_{n}^{n}= 2^{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.061108em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.061108em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.061108em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.93033em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></span>   <strong>①</strong></p><p>由性质1 可以推出：$m × C_{n}^{m} = n × C_{n-1}^{m-1} $ （展开了约分一下就行）</p><p>那么结合性质2可得：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msubsup><mi>C</mi><mi>n</mi><mn>1</mn></msubsup><mo>+</mo><mn>2</mn><msubsup><mi>C</mi><mi>n</mi><mn>2</mn></msubsup><mo>+</mo><mn>3</mn><msubsup><mi>C</mi><mi>n</mi><mn>3</mn></msubsup><mo>+</mo><mo>⋯</mo><mo>+</mo><mi>n</mi><msubsup><mi>C</mi><mi>n</mi><mi>n</mi></msubsup><mo>=</mo><mi>n</mi><msup><mn>2</mn><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">1 C_{n}^{1}+2 C_{n}^{2}+3 C_{n}^{3}+\cdots+n C_{n}^{n}=n 2^{n-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.061108em;vertical-align:-0.247em;"></span><span class="mord">1</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.061108em;vertical-align:-0.247em;"></span><span class="mord">2</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.061108em;vertical-align:-0.247em;"></span><span class="mord">3</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.93033em;vertical-align:-0.247em;"></span><span class="mord mathnormal">n</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord mathnormal">n</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> （不过这个式子本题用不到）</p><p>又因为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>m</mi><mn>2</mn></msup><mo>×</mo><msubsup><mi>C</mi><mi>n</mi><mi>m</mi></msubsup><mo>=</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo>×</mo><msubsup><mi>C</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></msubsup><mo>=</mo><mi>n</mi><mo>×</mo><msubsup><mi>C</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></msubsup><mo>+</mo><mi>n</mi><mo>×</mo><mo stretchy="false">(</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>×</mo><msubsup><mi>C</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></msubsup></mrow><annotation encoding="application/x-tex">m^2 × C_{n}^{m} = m × n × C_{n-1}^{m-1} =  n × C_{n-1}^{m-1}  + n × (m-1) × C_{n-1}^{m-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.93033em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.178878em;vertical-align:-0.324639em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.854239em;"><span style="top:-2.433692em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.1031310000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.324639em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.178878em;vertical-align:-0.324639em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.854239em;"><span style="top:-2.433692em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.1031310000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.324639em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.178878em;vertical-align:-0.324639em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.854239em;"><span style="top:-2.433692em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.1031310000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.324639em;"><span></span></span></span></span></span></span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>1</mn><mn>2</mn></msup><msubsup><mi>C</mi><mi>n</mi><mn>1</mn></msubsup><mo>+</mo><msup><mn>2</mn><mn>2</mn></msup><msubsup><mi>C</mi><mi>n</mi><mn>2</mn></msubsup><mo>+</mo><msup><mn>3</mn><mn>2</mn></msup><msubsup><mi>C</mi><mi>n</mi><mn>3</mn></msubsup><mo>+</mo><mo>⋯</mo><mo>+</mo><msup><mi>n</mi><mn>2</mn></msup><msubsup><mi>C</mi><mi>n</mi><mi>n</mi></msubsup><mo>=</mo><mi>n</mi><msup><mn>2</mn><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>+</mo><mi>n</mi><mo>×</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>×</mo><msup><mn>2</mn><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow></msup><mo>=</mo><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><msup><mn>2</mn><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow></msup></mrow><annotation encoding="application/x-tex">1^{2} C_{n}^{1}+2^{2} C_{n}^{2}+3^{2} C_{n}^{3}+\cdots+n^{2} C_{n}^{n}= n 2^{n-1} +n ×(n-1)×2^{n-2} =n(n+1) 2^{n-2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.061108em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.061108em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.061108em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.061108em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">n</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span> <strong>②</strong></p><hr /><p>以上是结论推导部分</p><p>这道题，我们实际需要求的是:</p><p><img src="https://picbed.octalzhihao.top/img/202412062129263.png" alt="" /></p><p>将①②式代入：简化答案为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>×</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>4</mn></mrow><annotation encoding="application/x-tex">(n+1)×n / 4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord">/</span><span class="mord">4</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 可求得。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pdd pair<span class="string">&lt;double, double&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pll pair<span class="string">&lt;ll, ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    ll res = (n<span class="number">+1</span>)*n / <span class="number">4</span>;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 比赛题解 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《数据库设计与开发》阅读笔记</title>
      <link href="/posts/16532.html"/>
      <url>/posts/16532.html</url>
      
        <content type="html"><![CDATA[<h1 id="chp1-数据库在电子商务中的角色"><a class="markdownIt-Anchor" href="#chp1-数据库在电子商务中的角色"></a> $chp1 数据库在电子商务中的角色</h1><h2 id="本书的组织"><a class="markdownIt-Anchor" href="#本书的组织"></a> 本书的组织</h2><p>第2章到第5章讨论数据库设计。</p><p>但是，在深入数据库设计之前，有必要了解数据库的开发环境和关系数据库设计的一些理论知识。</p><ul><li>第2章介绍数据库环境，定义了一些重要的术语并概括论述了关系数据库理论。</li></ul><p>我们可将数据库设计分为两大类，<strong>概念设计和逻辑设计</strong>。当进行概念设计时，您不必考虑前面提到的关系数据库的规则。</p><p>概念设计的实现是自由的，这意味着实现的精确意义是无关紧要的。</p><p>在<strong>概念设计期间您所要考虑的仅仅是数据库必须存储数据的实体</strong>，必须存储什么数据，以及实体之间是如何相互关联的。</p><ul><li><p>第3章和第5章介绍的是概念设计。</p></li><li><p>第4章讨论的重要主题是规范化，它是用来确保数据库的设计符合关系规则。违背这些规则会导致数据的不一致。</p></li></ul><p>介绍数据库实现和使用的章节是成对出现的，这是根据实现数据库设计所使用的数据库管理系统组织的。</p><ul><li>第6章讨论如何用 Oracle创建数据库表。第6章还包括对 Oracle 表中数据的插入、删除和更新。</li><li>第7章描述如何用 Oracle版本的结构查询语言（structured querylanguage，SQL）从数据库中检索数据。</li><li>第8章和第9章的内容与此相似，但使用的是Microsoft Access作为数据库管理系统。</li><li>第10和第11章介绍的是使用 Microsoft SQL Server创建和使用数据库。您的老师可能仅要求其中的一对章节，但您自己也许愿意浏览介绍其他数据库管理系统的章节。</li></ul><p>通过 Web前端（Webfront ends）对数据库的访问逐渐增多。换言之，更多的企业允许用户通过 Web 网页检索和操纵数据，而不是通过使用 SQL 直接与数据库管理系统进行交互。</p><ul><li>第12章描述使用 Web 网页访问数据。</li><li>第13章讨论通过Web页面更新数据库中的数据。</li></ul><h2 id="基础术语和概念"><a class="markdownIt-Anchor" href="#基础术语和概念"></a> 基础术语和概念</h2><blockquote><p>企业系统的四个组成部分：网络、硬件、软件和内容。</p></blockquote><p><img src="https://picbed.octalzhihao.top/img/202410142006570.png" alt="" /></p><p><strong>Database system</strong> <strong>with</strong> <strong>multiple user views</strong></p><img src="https://picbed.octalzhihao.top/img/202410142006571.png" height=300 align=left><h1 id="chp2-关系理论"><a class="markdownIt-Anchor" href="#chp2-关系理论"></a> $chp2 关系理论</h1><ul><li>描述关系模型。</li><li>识别实体关系图（ERD）中使用的符号。</li><li>定义和选择主键。</li><li>说明外键的职责。</li><li>识别和应用完整性规则。</li><li>说明关系数据库的优点。</li></ul><h2 id="22-关系模型"><a class="markdownIt-Anchor" href="#22-关系模型"></a> 2.2 关系模型</h2><h3 id="221-关系数据库管理系统rdbms"><a class="markdownIt-Anchor" href="#221-关系数据库管理系统rdbms"></a> 2.2.1 关系数据库管理系统（RDBMS）</h3><p><img src="https://picbed.octalzhihao.top/img/202410142006572.png" alt="image-20241014114048937" /></p><h3 id="222-数据库管理员dba"><a class="markdownIt-Anchor" href="#222-数据库管理员dba"></a> 2.2.2 数据库管理员（DBA）</h3><p><img src="https://picbed.octalzhihao.top/img/202410142006573.png" alt="image-20241014114200375" /></p><h2 id="23-实体关系图er图"><a class="markdownIt-Anchor" href="#23-实体关系图er图"></a> 2.3 实体关系图（ER图）</h2><p>属性在每个表中被建模为字段，字段在表中列出。</p><h3 id="一对多关系"><a class="markdownIt-Anchor" href="#一对多关系"></a> 一对多关系</h3><p><img src="https://picbed.octalzhihao.top/img/202410142006574.png" alt="image-20241014114320769" /></p><h3 id="多对多关系"><a class="markdownIt-Anchor" href="#多对多关系"></a> 多对多关系</h3><p><img src="https://picbed.octalzhihao.top/img/202410142006575.png" alt="image-20241014114424107" /></p><h3 id="231-主键"><a class="markdownIt-Anchor" href="#231-主键"></a> 2.3.1 主键</h3><blockquote><p>主键的特征：唯一的、最小的、非空、不可更新的<br />☆在主键的唯一性和最小化特性之间存在对立关系。在主键中包含越多的字段，唯一的机会就更大。<br />但是，最小化特性要求设计者找到最小的字段集合来形成一个唯一键。</p></blockquote><p>我们更愿意使用由一个字段构成的主键，这是由于它的简单性。但是，有时需要超过一个字段构成主键。</p><p>现有字段 or 计算机生成：</p><p><img src="https://picbed.octalzhihao.top/img/202410142006576.png" alt="image-20241014114820991" /></p><h3 id="232-外键"><a class="markdownIt-Anchor" href="#232-外键"></a> 2.3.2 外键</h3><p><strong>依赖表</strong>（dependent table，也被称为<strong>弱实体</strong>（weak entity) ），是需要用父表标识的子表。</p><p>依赖表常常将源于父表的外键作为主键的一部分合并进来。没有父表，依赖表在数据库中就不能存在。</p><p><img src="https://picbed.octalzhihao.top/img/202410142006577.png" alt="image-20241014114938101" /></p><p><strong>关联表</strong>（associative table）是多对多关系中两个父表的子表。</p><p><img src="https://picbed.octalzhihao.top/img/202410142006578.png" alt="image-20241014115305559" /></p><h3 id="233-数据完整性"><a class="markdownIt-Anchor" href="#233-数据完整性"></a> 2.3.3 数据完整性</h3><p>由于关系模型依赖主键识别实体，依赖外键创建关系，必须保持键的完整性（有效性）。<br />确保键的完整性的规则有两条：<br /><strong>实体完整性</strong>：每个表必须有一个有效的主键。实体完整性要求设计者在创建表时指定主键。不巧的是，大多数数据库产品不能遵守实体完整性一一只能要求设计者不要忘记指定主键。<br /><strong>参照完整性</strong>：没有不相匹配的外键值。参照完整性要求外键值与它们参照的表中的已有主键值相匹配。</p><p>example：</p><p><img src="https://picbed.octalzhihao.top/img/202410142006580.png" alt="image-20241014120245510" /></p><blockquote><p>Normalization的内容见chp4</p></blockquote><h2 id="24-数据库类型"><a class="markdownIt-Anchor" href="#24-数据库类型"></a> 2.4 数据库类型</h2><ul><li>层次的：IBM创造的信息管理系统（Information Management System，IMS）</li><li>网状的：IDMS</li><li>关系的：SQL</li><li>面向对象的：目前不主流</li></ul><h3 id="241-关系的优点"><a class="markdownIt-Anchor" href="#241-关系的优点"></a> 2.4.1 关系的优点</h3><p>工业上采用关系数据库模型是由于它能相当有效地增强生产力。我们将依次检验关系模型的下列优点：</p><ul><li><p>依赖于相关记录之间的逻辑链接而不是物理链接。</p></li><li><p>使用的是第四代语言。</p></li><li><p>允许高级别的数据独立性。</p></li></ul><h3 id="242-逻辑链接优于物理链接"><a class="markdownIt-Anchor" href="#242-逻辑链接优于物理链接"></a> 2.4.2 逻辑链接优于物理链接</h3><p><strong>只有关系模型才不依赖物理指针来链接数据项</strong>。</p><p><strong>指针链接相关的记录</strong>，例如，一个演员和一个演出队。</p><p>在<strong>基于物理指针的系统</strong>中，程序员必须编写过程来跟踪链接以检索信息。</p><p>相反，关系模型使用的是逻辑指针。</p><p>在<strong>关系系统</strong>中要将一个演员与一个演出队链接起来，只需简单地将外键记录与相对应的主键进行匹配就可以了。</p><h3 id="243-第四代编程语言4gl"><a class="markdownIt-Anchor" href="#243-第四代编程语言4gl"></a> 2.4.3 第四代编程语言（4GL）</h3><p>结构化查询语言（SQL）是关系数据库管理系统用于操纵数据的语言。</p><p><strong>结构化查询语言是第四代语言</strong>。</p><p>第一代计算机语言是二进制代码。</p><p>在第二代语言中通过汇编语言可得到二进制代码，汇编语言是二进制代码的文本缩写。</p><p>第三代语言包括编程语言，例如COBOL、C、Fortran、Pascal、Java、JavaScript 和VBScript。</p><p>结构化查询语言克服了3GL的两个约束。它是<strong>非过程性的</strong>（nonprocedural）和 <strong>面向表的</strong>（table oriented）。</p><blockquote><p><strong>“非过程性的”</strong> 是指编程人员只需指定期望的结果，而不需指定程序执行的每个步骤。此方法可得到非常简洁的程序。</p><p><strong>“面向表的”</strong> 是指允许SQL每次在一个完整的表上进行操作。SQL程序的输入是一个表或多个表，输出是一个表。因此，SQL不需要任何循环。相反，在3GL中，一个操作通常仅影响一个记录中的一个字段。遍历剩余的字段和记录需要使用循环。相比较而言，循环会增加很多行的代码从而使得3GL相当冗长。</p></blockquote><h3 id="224-数据独立性"><a class="markdownIt-Anchor" href="#224-数据独立性"></a> 2.2.4 数据独立性</h3><p>关系系统希望能有高级别的数据独立性。数据独立性使得 <strong>DBA可以重新组织数据的底层结构而不会引起应用服务器上的程序崩溃</strong>。DBA应该能够改变列名，并在表中移动列而不会影响应用。若这些改变是可能的，它们对于应用是透明的。<strong>数据独立性可使用视图获得</strong>。</p><p>开发者在数据库中创建的表被称为基础表（base tables）。这些表是我们自始至终都要使用的表。</p><p>相反，<strong>一个视图（view）是从这些表中导出的一个子集。</strong></p><p><strong>视图使得DBA可以限制每个用户可看到的数据库的区域。</strong></p><p>下图显示了同一个基础表MEMBER 上的两个不同视图。Member_email_view 仅包含address、first_name和last_name字段，而 member_phone_view仅包含first_name、last_name 和 telephone字段。注意在创建视图时对字段进行了重命名。Email被重命名为address，fname 被重命名为first_name，Iname 被重命名为last_name，phone被重命名为telephone。</p><p><img src="https://picbed.octalzhihao.top/img/202410142006581.png" alt="image-20241014125343403" /></p><h1 id="chp3-概念设计"><a class="markdownIt-Anchor" href="#chp3-概念设计"></a> $chp3 概念设计</h1><ul><li>以系统的方法设计一个ERD。</li><li>确定表之间的基数。</li><li>正确地选择表的主键。</li><li>识别子表的外键。</li><li>正确地为属性确定数据类型。</li></ul><h2 id="31-构建erd的五个步骤"><a class="markdownIt-Anchor" href="#31-构建erd的五个步骤"></a> 3.1 构建ERD的五个步骤</h2><ol><li><ul><li><strong>Step1：将实体表示为表</strong></li><li>有不止一个吗？您能设想该实体的多个实例吗？</li><li>随着时间的推移有变化吗？实例数量随时间变化吗？</li></ul></li><li><ul><li><strong>Step2：确定关系</strong></li><li>大多数情况下，一个表中的一条记录将对应于另一表中的多条记录。</li><li>对于多对多关系，必须在两个表之间创建一个新的关联表。</li></ul></li><li><ul><li><strong>Step3：列出字段</strong></li><li>如果步骤 1 中的表只有一个字段，那么它可能只是另一个表的字段。</li></ul></li><li><ul><li><strong>Step4：识别键</strong></li><li>所有表都必须有一个主键（唯一、最小、非空和不可更新）来唯一标识每条记录。</li></ul></li><li><ul><li><strong>Step5：确定数据类型</strong></li><li>字段的数据类型和大小必须匹配。</li></ul></li></ol><blockquote><p>本章内容主要介绍数据库的实例，暂时略过</p></blockquote><h1 id="chp4-规范化"><a class="markdownIt-Anchor" href="#chp4-规范化"></a> $chp4 规范化</h1><p>objective：</p><ul><li>解释主键的正确功能。</li><li>解释主键和规范化之间的关系。</li><li>检测一个非规范化的设计。</li><li>使用分步骤过程通过第四范式（4NF）对设计规范化。</li></ul><h2 id="42-规范化设计"><a class="markdownIt-Anchor" href="#42-规范化设计"></a> 4.2 规范化设计</h2><p>只有当每个字段只有一个值且每个表有正确的字段集，这个数据库才是规范的。</p><img src="https://picbed.octalzhihao.top/img/202410142006582.png" align=left><blockquote><p>BCNF是在开发4NF之后发现的。BCNF是对3NF的改进，可以处理不适用于 3NF的特殊情况。</p></blockquote><h3 id="421-非规范化设计"><a class="markdownIt-Anchor" href="#421-非规范化设计"></a> 4.2.1 非规范化设计</h3><ul><li><p>规范化的设计将实体放在分离的表中。对于这一点，我们的设计都是规范的。规范化设计避免了重复数据，或将相同信息存储多次。</p></li><li><p>相反，非规范化设计却保留了重复数据，有些时候可以提高查询效率。</p></li></ul><h2 id="43-arcade数据库的规范化"><a class="markdownIt-Anchor" href="#43-arcade数据库的规范化"></a> 4.3 Arcade数据库的规范化</h2><img src="https://picbed.octalzhihao.top/img/202410142006583.png" align=left><img src="https://picbed.octalzhihao.top/img/202410142006584.png" align=left><h3 id="431-更新问题"><a class="markdownIt-Anchor" href="#431-更新问题"></a> 4.3.1 更新问题</h3><p><img src="https://picbed.octalzhihao.top/img/202410142006585.png" alt="image-20241014133654183" /></p><h3 id="432-插入问题"><a class="markdownIt-Anchor" href="#432-插入问题"></a> 4.3.2 插入问题</h3><p><img src="https://picbed.octalzhihao.top/img/202410142006586.png" alt="image-20241014133717823" /></p><p><img src="https://picbed.octalzhihao.top/img/202410142006587.png" alt="image-20241014133909076" /></p><p><img src="https://picbed.octalzhihao.top/img/202410142006588.png" alt="image-20241014133917998" /></p><h2 id="44-范式"><a class="markdownIt-Anchor" href="#44-范式"></a> 4.4 范式</h2><h3 id="441-第一范式1fn"><a class="markdownIt-Anchor" href="#441-第一范式1fn"></a> 4.4.1 第一范式（1FN）</h3><ul><li><p><strong>定义</strong>：表中所有字段仅包含单值。</p></li><li><p>诊断出1NF违例的简单方法是找出包含超过一个单值的字段。</p></li></ul><p><strong>换句话说，第一范式就是要求数据库中的表都是二维表。</strong></p><h3 id="442-确定因子"><a class="markdownIt-Anchor" href="#442-确定因子"></a> 4.4.2 确定因子</h3><img src="https://picbed.octalzhihao.top/img/202410142006589.png" align=left><img src="https://picbed.octalzhihao.top/img/202410142006590.png" align=left><h3 id="442-第二范式2fn"><a class="markdownIt-Anchor" href="#442-第二范式2fn"></a> 4.4.2 第二范式（2FN）</h3><ul><li><strong>定义</strong>：表中的每个非键字段由整个主键确定，且不能由主键自身的一部分确定。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库设计——系统边界图</title>
      <link href="/posts/16493.html"/>
      <url>/posts/16493.html</url>
      
        <content type="html"><![CDATA[<h2 id="系统边界的定义"><a class="markdownIt-Anchor" href="#系统边界的定义"></a> 系统边界的定义</h2><p><strong>系统边界</strong>，即系统包含的功能与系统不包含的功能之间的界限。一般在系统分析阶段定义，只有明确了系统边界，才能继续进行下面的分析、设计等工作。</p><p>不论这个系统是产品还是项目。所谓边界，也就是将这个系统看成一个黑盒子，和外界的交互。</p><blockquote><p>“这，是一个黑色的立方体，长45厘米，宽23厘米，高3厘米，盒子的每个角都不尖锐，上方平坦，并有柔软质感；下方在四角之处都有凹进去的螺丝口，可以接杆子，以作凳子用。”</p></blockquote><p><strong>不清楚系统边界的后果</strong>：一是没有内外的概念，不知道需求描述的是什么；二是知道内外，然而对于边界的定义，没有足够的词语描述清楚，只能用对系统内部设计来代替。</p><h2 id="系统边界的确定"><a class="markdownIt-Anchor" href="#系统边界的确定"></a> 系统边界的确定</h2><p>先说说系统边界的确定。这是在工程开发中紧接着需求分析的第二步。</p><p>顾名思意，这个过程就是要确定我们要开发的系统和外部环境之间的界限，也就是要区分系统本身和它的外部环境。其中的外部环境可能包括用户,其它系统,软硬件条件等。</p><blockquote><p><strong>举个例子，一个银行系统，它的系统边界如何确定呢？</strong></p><p>首先，银行系统的外部活动者有储户,前台出纳员,银行管理员,这些都不属于银行系统本身，他们是此系统的外部环境；</p><p>其次，银行系统是运行在操作系统上的软件，它在运行过程中可能要进行生成文件,获取时间等操作，这涉及到操作系统的API，所以操作系统对于银行系统来说是外部环境；</p><p>再次，银行系统要打印交易凭条，打印机对于系统来说是外部环境；</p><p>第四，银行系统可能与客户的工作单位的工资发放系统有交互，那么客户工作单位的工资发放系统也是外部环境。</p><p>而对于银行系统来说，使用此系统的银行的建筑格局,人员构成,所处地域等就不是此系统的外部环境。</p></blockquote><p><strong>确定了系统的边界有什么用呢？</strong></p><p>系统边界一确定，我们就已经知道有哪些外部对象在与系统进行交互，于是我们就可以在系统中为该对象设计相应的接口，从而实现这些交互。</p><p>用上面的例子说，我们应该给储户,前台出纳,管理员设计不同的接口，还要给客户工作单位的工资发放系统设计接口，为打印机设计接口。</p><p>这些是我们需要关心的，如果这些外部环境改变了，我们可能要重新设计我们的接口。但不在系统边界上的因素我们就不用考虑，比如我们不必为银行建筑格局的改变而改变我们的系统接口，这是下水管道设计师应该关心的问题。</p><ul><li>确定系统边界在项目开发中是非常重要的一步，如果系统边界确定得不好，会给接下来的分析设计和编码工作带来障碍，也会给系统的维护带来麻烦。</li></ul><h2 id="系统边界图的定义"><a class="markdownIt-Anchor" href="#系统边界图的定义"></a> 系统边界图的定义</h2><p>​系统边界图是系统工程和软件工程中的一种图形化工具，用于描述系统与外部世界之间的交互和界限。它展示了<strong>系统的组成部分以及这些组件如何与外部实体进行通信和交互</strong>。**系统边界图通常包括系统内部的各个组件、外部实体以及它们之间的通信路径和数据流动。**这种图形化的表示方式能够帮助开发人员和利益相关者更清晰地理解系统的结构和功能，有助于指导系统设计、开发和测试工作。</p><h2 id="系统边界图的要素"><a class="markdownIt-Anchor" href="#系统边界图的要素"></a> 系统边界图的要素</h2><p>一般来说，系统边界图包括以下几个要素：</p><ol><li><strong>系统组件</strong>：系统的各个组成部分，通常以方框或圆圈表示。这些组件可以是软件模块、硬件设备或其他实体。</li><li><strong>外部实体</strong>：与系统进行交互的外部元素，比如用户、其他系统、设备等。外部实体通常用箭头表示与系统之间的交互。</li><li><strong>界限</strong>：表示系统与外部实体之间的边界，标志着系统的范围和责任。</li><li><strong>通信路径</strong>：描述系统组件之间以及系统与外部实体之间的通信路径，通常用箭头表示。</li><li><strong>数据流</strong>：表示信息或数据在系统内部和外部实体之间的流动路径。</li></ol><h2 id="系统边界图的创建步骤"><a class="markdownIt-Anchor" href="#系统边界图的创建步骤"></a> 系统边界图的创建步骤</h2><p>创建系统边界图的过程通常涉及以下步骤：</p><ol><li><strong>确定系统范围</strong>：明确系统的功能和边界，确定需要包含在系统边界图中的所有组件和外部实体。</li><li><strong>识别组件和实体</strong>：识别系统内部的各个组件以及与系统交互的外部实体。</li><li><strong>绘制边界</strong>：绘制系统边界，标明系统的范围。</li><li><strong>连接组件和实体</strong>：使用箭头表示组件之间的通信路径，以及系统与外部实体之间的交互。</li><li><strong>标注信息流</strong>：添加数据流以描述信息在系统内部和外部实体之间的传递路径。</li><li><strong>验证和完善</strong>：检查系统边界图，确保它清晰地描述了系统的结构和交互，同时完善任何可能存在的遗漏或错误。</li></ol><h2 id="系统边界图的案例"><a class="markdownIt-Anchor" href="#系统边界图的案例"></a> 系统边界图的案例</h2><p><em>copy from <a href="http://www.processon.com">www.processon.com</a></em></p><img src="https://picbed.octalzhihao.top/img/202410141927634.png"/><img src="https://picbed.octalzhihao.top/img/202410141930211.png"/><img src="https://picbed.octalzhihao.top/img/202410141929380.png"/><img src="https://picbed.octalzhihao.top/img/202410141929950.png"/>]]></content>
      
      
      <categories>
          
          <category> 数据库笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git提交规范</title>
      <link href="/posts/9200.html"/>
      <url>/posts/9200.html</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>commit message = subject + : + 空格 + message主体</strong></p></blockquote><p>常见的subject种类 如下：</p><h2 id="feat新功能feature"><a class="markdownIt-Anchor" href="#feat新功能feature"></a> feat：新功能（feature）</h2><ul><li>用于提交新功能</li></ul><blockquote><p>例如：feat: 增加用户管理模块</p></blockquote><h2 id="fix修复bug"><a class="markdownIt-Anchor" href="#fix修复bug"></a> fix：修复bug</h2><ul><li>用于提交bug修复</li></ul><blockquote><p>例如：fix: 修复刷新出现空白页面问题</p></blockquote><h2 id="docs文档变更"><a class="markdownIt-Anchor" href="#docs文档变更"></a> docs：文档变更</h2><ul><li>用于提交仅文档相关的修改</li></ul><blockquote><p>例如：docs: 更新README文件</p></blockquote><h2 id="style代码风格变动不影响代码逻辑"><a class="markdownIt-Anchor" href="#style代码风格变动不影响代码逻辑"></a> style：代码风格变动（不影响代码逻辑）</h2><ul><li>用于提交仅格式化、标点符号、空白等不影响代码运行的变更</li></ul><blockquote><p>例如：style: 删除多余空行和console打印</p></blockquote><h2 id="refactor代码重构既不是新增功能也不是修复bug的代码更改"><a class="markdownIt-Anchor" href="#refactor代码重构既不是新增功能也不是修复bug的代码更改"></a> refactor：代码重构（既不是新增功能也不是修复bug的代码更改）</h2><ul><li>用于提交代码重构</li></ul><blockquote><p>例如：refactor: 重构用户管理模块</p></blockquote><h2 id="perf性能优化"><a class="markdownIt-Anchor" href="#perf性能优化"></a> perf：性能优化</h2><ul><li>用于提交提升性能的代码修改</li></ul><blockquote><p>例如：perf: 优化图片加载速度</p></blockquote><h2 id="test添加或者修改测试"><a class="markdownIt-Anchor" href="#test添加或者修改测试"></a> test：添加或者修改测试</h2><ul><li>用于提交测试相关的内容</li></ul><blockquote><p>例如：test: 增加用户模块的测试单元</p></blockquote><h2 id="chore杂项构建过程或辅助工具的变动"><a class="markdownIt-Anchor" href="#chore杂项构建过程或辅助工具的变动"></a> chore：杂项（构建过程或辅助工具的变动）</h2><ul><li>用于提交构建过程、辅助工具等相关的内容修改</li></ul><blockquote><p>例如：chore: 更新依赖库</p></blockquote><h2 id="build构建系统或外部依赖项的变更"><a class="markdownIt-Anchor" href="#build构建系统或外部依赖项的变更"></a> build：构建系统或外部依赖项的变更</h2><ul><li>用于提交影响构建系统的更改</li></ul><blockquote><p>例如：build: 升级vite到版本4</p></blockquote><h2 id="ci持续集成配置的变更"><a class="markdownIt-Anchor" href="#ci持续集成配置的变更"></a> ci：持续集成配置的变更</h2><ul><li>用于提交CI配置文件和脚本的修改</li></ul><blockquote><p>例如：ci: 修改GitHub Actions配置文件</p></blockquote><h2 id="revert回滚"><a class="markdownIt-Anchor" href="#revert回滚"></a> revert：回滚</h2><ul><li>用于提交回滚之前的提交</li></ul><blockquote><p>例如：revert: 回滚 feat: 增加用户管理模块</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 实用手册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《知识图谱：方法、实践与应用》阅读笔记（2）知识图谱的存储</title>
      <link href="/posts/9155.html"/>
      <url>/posts/9155.html</url>
      
        <content type="html"><![CDATA[<h1 id="第三章-知识图谱的存储"><a class="markdownIt-Anchor" href="#第三章-知识图谱的存储"></a> 第三章 知识图谱的存储</h1><blockquote><p>引言：<br />一方面，以文件形式保存的知识图谱显然无法满足用户的查询、检索、推理、分析及各种应用需求；另一方面，传统数据库的关系模型与知识图谱的图模型之间存在显著差异，关系数据库无法有效地管理大规模知识图谱数据。<br />为了更好地进行三元组数据的存储，语义万维网领域发展出专门存储RDF 数据的三元组库；数据库领域发展出用于管理属性图的图数据库。</p></blockquote><h2 id="31-知识图谱数据库基本知识"><a class="markdownIt-Anchor" href="#31-知识图谱数据库基本知识"></a> 3.1 知识图谱数据库基本知识</h2><blockquote><p>两种主要图数据模型：RDF 图和属性图</p></blockquote><h3 id="311-知识图谱数据模型"><a class="markdownIt-Anchor" href="#311-知识图谱数据模型"></a> 3.1.1 知识图谱数据模型</h3><p>知识图谱数据模型的数学基础源于有着近 300年历史的数学分支——图论。</p><h4 id="1-rdf图"><a class="markdownIt-Anchor" href="#1-rdf图"></a> <strong>1. RDF图</strong></h4><p>RDF 是 W3C 制定的在语义万维网上表示和交换机器可理解信息的标准数据模型。在 RDF 三元组集合中，每个 Web 资源具有一个 HTTP URI 作为其唯一的 id。</p><blockquote><p>HTTP URI（Uniform Resource Identifier）是一种用于标识Web资源的标准化字符串。URI是一种通用的资源标识方案，其中HTTP URI是基于HTTP协议的特定类型。它有两种主要的格式：</p><ol><li><p>URL（Uniform Resource Locator）：</p><p>常见的Web地址，表示资源的位置。</p><ul><li>示例：<code>http://example.com/page</code> 表示某个网站上的页面。</li></ul></li><li><p>URN（Uniform Resource Name）： 仅用于标识资源的名称，但不指示具体的访问方式或位置（在实践中较少使用）。</p></li></ol></blockquote><p>一个 RDF 图定义为三元组 (<em>s</em>, <em>p</em>, <em>o</em>) 的有限集合；每个三元组代表一个陈述句，其中 <em>s</em> 是主语，<em>p</em> 是谓语，<em>o</em> 是宾语；(<em>s</em>, <em>p</em>, <em>o</em>) 表示资源 <em>s</em> 与资源 <em>o</em> 之间具有联系 <em>p</em>，或表示资源 <em>s</em> 具有属性 <em>p</em> 且其取值为 <em>o</em>。实际上，RDF 三元组集合即为图中的有向边集合。</p><p><img src="https://picbed.octalzhihao.top/img/20250309140313683.png" alt="image-20241017194908803" /></p><p><strong>值得注意的是，RDF 图对于节点和边上的属性没有内置的支持。</strong></p><p><strong>节点属性</strong>可用三元组表示，这类三元组的宾语称为字面量，即图中的矩形。例如，（ex: zhangsan, 姓名, “张三”）。</p><p>边上的属性常利用一种叫做 **“具体化”（reification）**的技术，额外引入关系节点表示整个三元组，将边属性表示为以该节点为主语的三元组。</p><p>例如在图 3-2 中，引入节点<code>ex:participate</code> 代表三元组 <code>(ex:zhangsan, 参加, ex:graphdb)</code> ，该节点通过 RDF 内置属性 <code>rdf:subject</code>、<code>rdf:predicate</code> 和 <code>rdf:object</code> 分别与代表的三元组的主语、谓语和宾语建立起联系，这样三元组(ex:participate, 权重, 0.4)就实现了为原三元组增加边属性的效果。</p><p><img src="https://picbed.octalzhihao.top/img/20250309140313685.png" alt="image-20241017195459046" /></p><h4 id="2-属性图"><a class="markdownIt-Anchor" href="#2-属性图"></a> 2. 属性图</h4><blockquote><p><strong>个人理解：所有节点都是一个map的有向图</strong></p></blockquote><p>​属性图可以说是目前被图数据库业界采纳最广的一种图数据模型。属性图由节点集和边集组成，且满足如下性质：</p><p>（1）每个节点具有唯一的 id；</p><p>（2）每个节点具有若干条出边；</p><p>（3）每个节点具有若干条入边；</p><p>（4）每个节点具有一组属性，每个属性是一个键值对；</p><p>（5）每条边具有唯一的 id；</p><p>（6）每条边具有一个头节点；</p><p>（7）每条边具有一个尾节点；</p><p>（8）每条边具有一个标签，表示联系；</p><p>（9）每条边具有一组属性，每个属性是一个键值对。</p><p><img src="https://picbed.octalzhihao.top/img/20250309140313687.png" alt="image-20241017195932080" /></p><h3 id="312-知识图谱查询语言"><a class="markdownIt-Anchor" href="#312-知识图谱查询语言"></a> 3.1.2 知识图谱查询语言</h3><p>目前，RDF 图上的查询语言是 SPARQL；</p><p>属性图上的查询语言常用的是 Cypher 和 Gremlin。</p><h4 id="1-sparql"><a class="markdownIt-Anchor" href="#1-sparql"></a> 1. SPARQL</h4><p>举个栗子：</p><p>（1）查询程序员张三认识的其他程序员</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PREFIX ex: &lt;http://www.example.com/&gt;</span><br><span class="line">SELECT ?p</span><br><span class="line">WHERE &#123; ex:zhangsan ex:knows ?p . &#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ex:lisi</span><br><span class="line">ex:wangwu</span><br></pre></td></tr></table></figure><p>说明：PREFIX 关键字将 ex 定义为 URI <code>http://www.example.com/</code> 的前缀缩写，WHERE 关键字指明了查询的三元组模式（Triple Pattern），SELECT 关键字列出了要返回的结果变量。三元组模式查询是最基本的 SPARQL 查询。</p><h4 id="2cypher"><a class="markdownIt-Anchor" href="#2cypher"></a> 2．Cypher</h4><p>Cypher 最初是图数据库 Neo4j 中实现的属性图数据查询语言。</p><p>与 SPARQL 一样，Cypher 也是一种声明式语言，即用户只需要声明“查什么”，而无须关心“怎么查”。（和SQL一样）</p><p>举个栗子：</p><p>（1）查询图中的所有程序员节点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MATCH (p:程序员)</span><br><span class="line">RETURN p</span><br></pre></td></tr></table></figure><p>​输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;姓名=张三, 年龄=29&#125;</span><br><span class="line">&#123;姓名=李四, 年龄=27&#125;</span><br><span class="line">&#123;姓名=王五, 年龄=32&#125;</span><br><span class="line">&#123;姓名=赵六, 年龄=35&#125;</span><br></pre></td></tr></table></figure><p>（2）查询程序员与“图数据库”项目之间的边</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MATCH (:程序员)-[r]-&gt;(:项目&#123;name:&#x27;图数据库&#x27;&#125;)</span><br><span class="line">RETURN r</span><br></pre></td></tr></table></figure><p>​输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(1)-[参加&#123;权重=0.4&#125;]-&gt;(3)</span><br><span class="line">(4)-[参加&#123;权重=0.4&#125;]-&gt;(3)</span><br><span class="line">(6)-[参加&#123;权重=0.2&#125;]-&gt;(3)</span><br></pre></td></tr></table></figure><h4 id="3gremlin"><a class="markdownIt-Anchor" href="#3gremlin"></a> 3．Gremlin</h4><p>Gremlin 是 Apache TinkerPop 图计算框架提供的属性图查询语言。</p><p>Gremlin 的定位是<strong>图遍历语言</strong>，其执行机制好比是一个人置身于图中沿着有向边，从一个节点到另一个节点进行导航式的游走。</p><p>这类语言的优点是可以时刻知道自己在图中所处的位置，以及是如何到达该位置的；缺点是用户需要“认识路”！</p><p>与受到SQL 影响的声明式语言 SPARQL 和 Cypher 不同，Gremlin 更像一种函数式的编程语言接口。</p><p>举个栗子：</p><p>（1）列出图中所有节点的属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g.V</span><br></pre></td></tr></table></figure><p>​输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;姓名=张三, 年龄=29&#125;</span><br><span class="line">&#123;姓名=李四, 年龄=27&#125;</span><br><span class="line">&#123;项目=图数据库, 语言=Java&#125;</span><br><span class="line">&#123;姓名=王五, 年龄=32&#125;</span><br><span class="line">&#123;项目=RDF 三元组库, 语言=C++&#125;</span><br><span class="line">&#123;姓名=赵六, 年龄=35&#125;</span><br></pre></td></tr></table></figure><p>​说明：V 表示节点集合。</p><p>（2）列出图中所有的边</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g.E</span><br></pre></td></tr></table></figure><p>​输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">e[7][1-认识-&gt;2]</span><br><span class="line">e[8][1-认识-&gt;4]</span><br><span class="line">e[9][1-参加-&gt;3]</span><br><span class="line">e[10][4-参加-&gt;5]</span><br><span class="line">e[11][4-参加-&gt;3]</span><br><span class="line">e[12][6-参加-&gt;3]</span><br></pre></td></tr></table></figure><p>​说明：E 表示边集合。</p><p>（3）查询从节点 1 出发的标签为“认识”的边</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g.v(1).outE(&#x27;认识&#x27;)</span><br></pre></td></tr></table></figure><p>​输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e[7][1-认识-&gt;2]</span><br><span class="line">e[8][1-认识-&gt;4]</span><br></pre></td></tr></table></figure><p>​说明：v(1)选取 id 为 1 的节点；outE 表示节点的出边集合，outE(‘认识’)是标签为“认识”的出边集合。</p><h2 id="32-常见知识图谱存储方式"><a class="markdownIt-Anchor" href="#32-常见知识图谱存储方式"></a> 3.2 常见知识图谱存储方式</h2><p>本节介绍三类知识图谱数据库：</p><ol><li><p>基于关系数据库的存储方案</p></li><li><p>面向 RDF 的三元组数据库</p></li><li><p>原生图数据库</p></li></ol><h3 id="321-基于关系数据库的存储方案"><a class="markdownIt-Anchor" href="#321-基于关系数据库的存储方案"></a> 3.2.1 基于关系数据库的存储方案</h3><h4 id="1三元组表"><a class="markdownIt-Anchor" href="#1三元组表"></a> 1．三元组表</h4><p>三元组表是将知识图谱存储到关系数据库的最简单、最直接的办法，就是在关系数据库中建立一张具有 3 列的表，该表的模式为</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>三元组表</mtext><mo stretchy="false">(</mo><mtext>主语</mtext><mo separator="true">,</mo><mtext>谓语</mtext><mo separator="true">,</mo><mtext>宾语</mtext><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">三元组表 (主语, 谓语, 宾语)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">三</span><span class="mord cjk_fallback">元</span><span class="mord cjk_fallback">组</span><span class="mord cjk_fallback">表</span><span class="mopen">(</span><span class="mord cjk_fallback">主</span><span class="mord cjk_fallback">语</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">谓</span><span class="mord cjk_fallback">语</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">宾</span><span class="mord cjk_fallback">语</span><span class="mclose">)</span></span></span></span><br /><img src="https://picbed.octalzhihao.top/img/20250309140313688.png" alt="" /></p><p>三元组表存储方案虽然简单明了，但三元组表的行数与知识图谱的边数一样，<strong>其最大问题在于将知识图谱查询翻译为 SQL 查询后的三元组表自连接</strong>。</p><p>查找 1850 年出生且 1934 年逝世的创办了某公司的人：</p><p><img src="https://picbed.octalzhihao.top/img/20250309140313689.png" alt="image-20241017202549628" /></p><h4 id="2水平表"><a class="markdownIt-Anchor" href="#2水平表"></a> 2．水平表</h4><p>水平表每行记录存储一个知识图谱中一个主语的所有谓语和宾语。</p><p>实际上，水平表就相当于知识图谱的邻接表。</p><p><img src="https://picbed.octalzhihao.top/img/20250309140313690.png" alt="image-20241017202710419" /></p><p>优点：</p><p><img src="https://picbed.octalzhihao.top/img/20250309140313691.png" alt="image-20241017202750982" /></p><p>缺点：存在大量空值，浪费空间。</p><blockquote><p>但是水平表的缺点在于：所需列的数目等于知识图谱中不同谓语数量，在真实知识图谱数据集中，不同谓语数量可能为几千个到上万个，很可能超出关系数据库允许的表中列数目的上限；对于一行来说，仅在极少数列上具有值，表中存在大量空值。</p></blockquote><h4 id="3属性表"><a class="markdownIt-Anchor" href="#3属性表"></a> 3．属性表</h4><p>属性表（Property Table）存储方案是对水平表的细化，将同类主语分到一个表中，不同类主语分到不同表中。这样就解决了表中列的数目过多的问题。</p><p><img src="https://picbed.octalzhihao.top/img/20250309140313692.png" alt="image-20241017203032601" /></p><p><img src="https://picbed.octalzhihao.top/img/20250309140313693.png" alt="image-20241017203045971" /></p><p><strong>属性表既克服了三元组表的自连接问题，又解决了水平表中列数目过多的问题。</strong></p><p>但属性表方案仍有缺点：</p><ul><li>对于规模稍大的真实知识图谱数据，主语的类别可能有几千个到上万个，按照属性表方案，需要<strong>建立几千个到上万个表</strong>，这往往超过了关系数据库的限制。</li><li>对于知识图谱上稍复杂的查询，属性表方案仍然会进行<strong>多个表之间的连接操作</strong>，从而影响查询效率。</li><li>即使在同一类型中，不同主语具有的<strong>谓语集合也可能存在较大差异</strong>，这样会造成与水平表中类似的空值问题。</li></ul><blockquote><p>采用属性表存储方案的代表是 RDF 三元组库 Jena。</p></blockquote><h4 id="4垂直划分"><a class="markdownIt-Anchor" href="#4垂直划分"></a> 4．垂直划分</h4><p>垂直划分（Vertical Partitioning）存储方案是由美国麻省理工学院的 Abadi 等人在 2007 年提出的 RDF 数据存储方法。</p><p>该方法以三元组的谓语作为划分维度，将 RDF 知识图谱划分为若干张只包含(主语, 宾语)两列的表，表的总数量即知识图谱中不同谓语的数量；<strong>也就是说，为每种谓语建立一张表</strong>，表中存放知识图谱中由该谓语连接的主语和宾语值。</p><p><img src="https://picbed.octalzhihao.top/img/20250309140313694.png" alt="image-20241017210221122" /></p><blockquote><p>每个谓语表都按主语列的值进行排序，能够使用归并排序连接（Merge-sort Join）快速执行不同谓语表的连接查询操作。</p></blockquote><h4 id="5六重索引"><a class="markdownIt-Anchor" href="#5六重索引"></a> 5．六重索引</h4><p>六重索引（Sextuple Indexing）存储方案是对<strong>三元组表的扩展</strong>，是一种典型的“空间换时间”策略，其将三元组全部 6 种排列对应地建立为 6 张表。</p><p>六重索引存储方案存在的问题包括：虽然部分缓解了三元组表的单表自连接问题，但需要花费 6 倍的存储空间开销、索引维护代价和数据更新时的一致性维护代价。</p><p><img src="https://picbed.octalzhihao.top/img/20250309140313695.png" alt="image-20241017210456654" /></p><h4 id="6db2rdf"><a class="markdownIt-Anchor" href="#6db2rdf"></a> 6．DB2RDF</h4><p>DB2RDF 是由 IBM 研究中心于 2013 年提出的一种<strong>面向实体</strong>的 RDF 知识图谱存储方案，该方案是以往 RDF 关系存储方案的一种权衡折中，既具备了三元组表、属性表和垂直划分方案的部分优点，又克服了这些方案的部分缺点。</p><p>三元组表的优势在于“行维度”上的灵活性，即存储模式不会随行的增加而变化；DB2RDF 方案将这种灵活性扩展到“列维度”上，即<strong>将表的列作为谓语和宾语的存储位置，而不将列与谓语进行绑定</strong>。</p><p>DB2RDF 存储方案由 4 张表组成，即 dph 表、rph 表、ds 表和 rs 表；图 3-13 给出了 图 3-4 中知识图谱对应的 DB2RDF 存储方案。</p><ul><li><p>**dph（direct primary hash）**是存储方案的主表，该表中一行存储一个主语（主语列）及其全部谓语（pred<em>i</em> 列）和宾语（val<em>i</em> 列）。</p></li><li><p>对于多值谓语的处理，引入 <strong>ds（direct secondary hash）表</strong>。当 dph 表中遇到一个多值谓语时，则在相应的宾语处生成一个唯一的 id 值；将该 id 值和每个对应的宾语存储为 ds表的一行。例如，在图 3-13 的 dph 表中，主语 Google 的谓语 industry（pred1 列）是多值谓语，则在其宾语列（val1）存储 id 值 lid:1；在 ds 表中存储 lid:1 关联的两个宾语Software 和 Internet。</p></li><li><p>为了提高查询处理效率，还需要存储实体节点的入边信息（从宾</p><p>语经谓语到主语）。为此，DB2RDF 方案提供了 <strong>rph（reverse primary hash）表和 rs（reverse secondary hash）表</strong>。</p></li></ul><p><img src="https://picbed.octalzhihao.top/img/20250309140313696.png" alt="image-20241017210819612" /></p><p><img src="https://picbed.octalzhihao.top/img/20250309140313697.png" alt="image-20241017210829010" /></p><h4 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h4><p><img src="https://picbed.octalzhihao.top/img/20250309140313698.png" alt="image-20241017210329270" /></p><h3 id="323-原生图数据库"><a class="markdownIt-Anchor" href="#323-原生图数据库"></a> 3.2.3 原生图数据库</h3>]]></content>
      
      
      <categories>
          
          <category> 知识图谱 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识图谱 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《知识图谱：方法、实践与应用》阅读笔记（1）知识图谱表示与建模</title>
      <link href="/posts/56649.html"/>
      <url>/posts/56649.html</url>
      
        <content type="html"><![CDATA[<h1 id="第二章-知识图谱表示与建模"><a class="markdownIt-Anchor" href="#第二章-知识图谱表示与建模"></a> 第二章 知识图谱表示与建模</h1><blockquote><p>知识图谱表示（Knowledge Graph Representation）指的是用什么语言对知识图谱进行建模，从而可以方便知识计算。从图的角度来看，知识图谱是一个语义网络，即一种用互联的节点和弧表示知识的一个结构。</p></blockquote><h2 id="21-什么是知识表示"><a class="markdownIt-Anchor" href="#21-什么是知识表示"></a> 2.1 什么是知识表示</h2><p>无论是语义网络，还是框架语言和产生式规则，都缺少严格的语义理论模型和形式化的语义定义。为了解决这一问题，人们开始研究具有较好的理论模型基础和算法复杂度的知识表示框架。比较有代表性的是描述逻辑语言（Description Logic）。描述逻辑是目前大多数本体语言（如 OWL）的理论基础。</p><p><strong>语义网的基础数据模型 RDF</strong> 受到了元数据模型、框架系统和面向对象语言等多方面的影响，其最初是为人们在 Web 上发布结构化数据提供一个标准的数据描述框架。</p><p>与此同时，语义网进一步吸收<strong>描述逻辑的研究成果</strong>，发展出了用 <strong>OWL 系列</strong>标准化本体语言。</p><p>随着表示学习的发展，以及自然语言处理领域词向量等嵌入（Embedding）技术手段的出现，启发了人们用<strong>类似于词向量的低维稠密向量的方式表示知识</strong>。通过嵌入将知识图谱中的实体和关系投射到一个低维的连续向量空间，可以为每一个实体和关系学习出一个低维度的向量表示。</p><p><img src="https://picbed.octalzhihao.top/img/202503091240263.png" alt="image-20241019142826881" /></p><h2 id="22-人工智能早期的知识表示方法"><a class="markdownIt-Anchor" href="#22-人工智能早期的知识表示方法"></a> 2.2 人工智能早期的知识表示方法</h2><h3 id="221-一阶谓词逻辑"><a class="markdownIt-Anchor" href="#221-一阶谓词逻辑"></a> 2.2.1 一阶谓词逻辑</h3><p>一阶谓词逻辑（或简称一阶逻辑）（First Order Logic）是公理系统的标准形式逻辑。</p><p><img src="https://picbed.octalzhihao.top/img/202503091240265.png" alt="image-20241019143006048" /></p><h3 id="222-霍恩子句和霍恩逻辑"><a class="markdownIt-Anchor" href="#222-霍恩子句和霍恩逻辑"></a> 2.2.2 霍恩子句和霍恩逻辑</h3><p><strong>霍恩子句</strong>（Horn Clause）得名于逻辑学家 Alfred Horn[6]。一个子句是文字的析取。</p><p><strong>霍恩逻辑</strong>（Horn Logic）是一阶逻辑的子集。基于霍恩逻辑的知识库是一个霍恩规则的集合。</p><p><img src="https://picbed.octalzhihao.top/img/202503091240266.png" alt="image-20241019143159251" /></p><h3 id="223-语义网络"><a class="markdownIt-Anchor" href="#223-语义网络"></a> 2.2.3 语义网络</h3><p><strong>语义网络又称联想网络</strong>，它在形式上是一个带标识的有向图。</p><p>**图中“节点”**用以表示各种事物、概念、情况、状态等。每个节点可以带有若干属性。</p><p><strong>节点与节点间的“连接弧”</strong>（称为联想弧）用以表示各种语义联系、动作。</p><p>语义网络的单元是三元组：（节点 1, 联想弧, 节点 2）。</p><blockquote><p>例如（Tim Berners-Lee, 类型, 图灵奖得主）和（Tim Berners-Lee, 发明, 互联网）是三元组。</p></blockquote><p>由于所有的节点均通过联想弧彼此相连，语义网络可以通过图上的操作进行知识推理。</p><p><img src="https://picbed.octalzhihao.top/img/202503091240267.png" alt="image-20241019143402422" /></p><p><img src="https://picbed.octalzhihao.top/img/202503091240268.png" alt="image-20241019143435814" /></p><h3 id="224-框架"><a class="markdownIt-Anchor" href="#224-框架"></a> 2.2.4 框架</h3><p>框架（Frame）最早由 Marvin Minsky 在 1975 年提出，目标是更好地理解视觉推理和自然语言处理。<strong>其理论的基本思想是</strong>：认为人们对现实世界中各种事物的认识都以一种类似于框架的结构存储在记忆中。当面临一个新事物时，就从记忆中找出一个合适的框架，并根据实际情况对其细节加以修改、补充，从而形成对当前事物的认识。</p><p><img src="https://picbed.octalzhihao.top/img/202503091240269.png" alt="image-20241019143644855" /></p><p><img src="https://picbed.octalzhihao.top/img/202503091240270.png" alt="image-20241019143656145" /></p><h3 id="225-描述逻辑"><a class="markdownIt-Anchor" href="#225-描述逻辑"></a> 2.2.5 描述逻辑</h3><p>描述逻辑可以被看成是利用一阶逻辑对语义网络和框架进行形式化后的产物。</p><p>描述逻辑一般支持一元谓词和二元谓词。**一元谓词称为类，二元谓词称为关系。**描述逻辑的重要特征是同时具有很强的表达能力和可判定性。描述逻辑近年来受到广泛关注，被选为 <strong>W3C 互联网本体语言（OWL）的理论基础</strong>。</p><p><img src="https://picbed.octalzhihao.top/img/202503091240271.png" alt="image-20241019143818526" /></p><h2 id="23-互联网时代的语义网知识表示框架"><a class="markdownIt-Anchor" href="#23-互联网时代的语义网知识表示框架"></a> 2.3 互联网时代的语义网知识表示框架</h2><p>着语义网的提出，知识表示迎来了新的契机和挑战，<strong>契机在于</strong>语义网为知识表示提供了一个很好的应用场景，<strong>挑战在于</strong>面向语义网的知识表示需要提供一套标准语言可以用来描述 Web 的各种信息。</p><p>早期 Web 的标准语言 HTML 和 XML 无法适应语义网对知识表示的要求，所以 W3C 提出了<strong>新的标准语言 RDF、RDFS 和 OWL</strong>。这两种语言的语法可以跟 XML 兼容。</p><h3 id="231-rdf-和-rdfs"><a class="markdownIt-Anchor" href="#231-rdf-和-rdfs"></a> 2.3.1 RDF 和 RDFS</h3><p>RDF 是 W3C 的 RDF 工作组制定的关于知识图谱的国际标准。RDF 是 W3C 一系列语义网标准的核心，如图 2-4 所示。</p><ul><li>表示组（Representation）包括 URI/IRI、XML 和 RDF。前两者主要是为 RDF 提供语法基础。</li><li>推理组（Reasoning）包括 RDF-S、本体 OWL、规则 RIF 和统一逻辑。统一逻辑目前还没有定论。</li><li>信任组和用户互动组。</li></ul><p><img src="https://picbed.octalzhihao.top/img/202503091240272.png" alt="image-20241019144210782" /></p><p>2006 年，人们开始用 RDF 发布和链接数据，从而生成知识图谱.</p><p><img src="https://picbed.octalzhihao.top/img/202503091240274.png" alt="image-20241019144532572" /></p><h4 id="1rdf-简介"><a class="markdownIt-Anchor" href="#1rdf-简介"></a> 1．RDF 简介</h4><p>在 RDF 中，知识总是以三元组的形式出现。每一份知识可以被分解为如下形式：<code>(subject, predicate, object)</code>。</p><blockquote><p>例如，“IBM 邀请 Jeff Pan 作为讲者，演讲主题是知识图谱”可以写成以下 RDF 三元组：（IBM-Talk,speaker,Jeff）,（IBM-Talk,theme,KG）。</p></blockquote><p>RDF 中的<strong>主语</strong>是一个个体（Individual），个体是类的实例。</p><p>RDF 中的<strong>谓语</strong>是一个属性。属性可以连接两个个体，或者连接一个个体和一个数据类型的实例。</p><p>换言之，RDF 中的<strong>宾语</strong>可以是一个个体，例如（IBM-Talk,speaker,Jeff）也可以是一个数据类型的实例，例如（IBMTalk,talkDate,“05-10-2012”^xsd:date）。</p><ul><li>如果把三元组的主语和宾语看成图的节点，三元组的谓语看成边，那么一个 RDF 知识库则可以被看成一个图或一个知识图谱</li></ul><p><img src="https://picbed.octalzhihao.top/img/202503091240275.png" alt="image-20241019144901316" /></p><ul><li><p>全局标识 URI 可以被简化成前缀 URI。</p></li><li><p>RDF 允许没有全局标识的空白节点（Blank Node）。空白节点的前缀为“_”。</p></li></ul><p><img src="https://picbed.octalzhihao.top/img/202503091240276.png" alt="image-20241019145014237" /></p><h4 id="2开放世界假设"><a class="markdownIt-Anchor" href="#2开放世界假设"></a> 2．开放世界假设</h4><p>不同于经典数据库采用封闭世界假设，RDF 采用的是开放世界假设。也就是说，RDF图谱里的知识有可能是不完备的，这符合 Web 的 开 放 性 特 点 和 要 求 。</p><h2 id="todo"><a class="markdownIt-Anchor" href="#todo"></a> TODO</h2><h2 id="25-知识图谱的向量表示方法"><a class="markdownIt-Anchor" href="#25-知识图谱的向量表示方法"></a> 2.5 知识图谱的向量表示方法</h2><p>本节要描述的方法是把知识图谱中的实体和关系<strong>映射到低维连续的向量空间</strong>，而不是使用基于离散符号的表达方式。</p><h3 id="251-知识图谱表示的挑战"><a class="markdownIt-Anchor" href="#251-知识图谱表示的挑战"></a> 2.5.1 知识图谱表示的挑战</h3><p>在前面提到的一些知识图谱的表示方法中，其基础大多是以三元组的方法对知识进行组织。</p><p>知识<strong>以基于离散符号的方法进行表达</strong>，但这些符号并不能在计算机中表达相应语义层面的信息，也<strong>不能进行语义计算</strong>，对下游的一些应用并不友好。</p><p>在基于网络结构的知识图谱上进行相关应用时，因为图结构的特殊性，应用算法的使用<strong>与图算法有关，相关算法具有较高的复杂度</strong>，面对大规模的知识库很难扩展。</p><p>对于当前的数据量较大的知识图谱、变化各异的应用来说，需要改进传统的表示方法。</p><h3 id="252-词的向量表示方法"><a class="markdownIt-Anchor" href="#252-词的向量表示方法"></a> 2.5.2 词的向量表示方法</h3><h4 id="1独热编码"><a class="markdownIt-Anchor" href="#1独热编码"></a> 1．独热编码</h4><p>方法简单，但没有编码语义层面的信息，稀疏性非常强，当整个词典非常大时，编码出向量的维度也会很大。</p><h4 id="2词袋模型"><a class="markdownIt-Anchor" href="#2词袋模型"></a> 2．词袋模型</h4><p>词袋模型（Bag-of-Words，BoW）是一种对文本中词的表示方法。</p><blockquote><p>类似于cnt数组</p></blockquote><p>该方法将文本想象成一个装词的袋子，不考虑词之间的上下文关系，不关心词在袋子中存放的顺序，仅记录每个词在该文本（词袋）中出现的次数。</p><h4 id="3词向量"><a class="markdownIt-Anchor" href="#3词向量"></a> 3．词向量</h4><p>上面对词的表示方法并没有考虑语义层面的信息，为了更多地表示<strong>词与词之间的语义相似程度</strong>，提出词的分布式表示，也就是基于上下文的稠密向量表示法，通常称为<strong>词向量或词嵌入（Word Embedding）</strong>。产生词向量的手段主要有三种：</p><ul><li><p>Count-based。基于计数的方法，简单说就是记录文本中词的出现次数。</p></li><li><p>Predictive。基于预测的方法，既可以通过上下文预测中心词，也可以通过中心词预测上下文。</p></li><li><p>Task-based。基于任务的，也就是通过任务驱动的方法。通过对词向量在具体任务上的表现效果对词向量进行学习</p></li></ul><p>经典的开源工具 <code>word2vec</code> 中包含的 <code>CBoW</code> 和 <code>Skip-gram</code> 两个模型。</p><ul><li><p>CBoW 也就是连续词袋模型（Continuous Bag-of-Words），和之前提到的 BoW 相似之处在于该模型也不用考虑词序的信息。<strong>其主要思想是，用上下文预测中心词，从而训练出的词向量包含了一定的上下文信息。<strong>整个模型在训练的过程就像是一个窗口在训练语料上进行滑动，所以被称为</strong>连续词袋模型</strong>。</p></li><li><p>Skip-gram 的思想与 CBoW 恰恰相反，<strong>其考虑用中心词来预测上下文词。</strong></p></li></ul><blockquote><p>CBoW：如图 2-21（a）所示，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>𝒘</mi><mi>𝑛</mi></msub></mrow><annotation encoding="application/x-tex">𝒘_𝑛</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.59444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord boldsymbol" style="margin-right:0.11111em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.11111em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是中心词，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>𝒘</mi><mrow><mi>𝑛</mi><mtext>−</mtext><mn>2</mn></mrow></msub></mrow><annotation encoding="application/x-tex">𝒘_{𝑛−2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.652771em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord boldsymbol" style="margin-right:0.11111em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.11111em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mtight">−</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>𝒘</mi><mrow><mi>𝑛</mi><mtext>−</mtext><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">𝒘_{𝑛−1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.652771em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord boldsymbol" style="margin-right:0.11111em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.11111em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>𝒘</mi><mrow><mi>𝑛</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">𝒘_{𝑛+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.652771em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord boldsymbol" style="margin-right:0.11111em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.11111em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>𝒘</mi><mrow><mi>𝑛</mi><mo>+</mo><mn>2</mn></mrow></msub></mrow><annotation encoding="application/x-tex">𝒘_{𝑛+2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.652771em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord boldsymbol" style="margin-right:0.11111em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.11111em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span> 为该中心词的上下文的词。将上下文词的独热表示与词向量矩阵 𝑬 相乘，提取相应的词向量并求和得到投影层，然后再经过一个 Softmax 层最终得到输出，<strong>输出的每一维表达的就是词表中每个词作为该上下文的中心词的概率。</strong></p></blockquote><blockquote><p>Skip-gram：如图 2-21（b）所示，先通过中心词的独热表示从词向量矩阵中得到中心词的词向量得到投影层，然后经过一层Softmax 得到输出，<strong>输出的每一维中代表某个词作为输入中心词的上下文出现的概率。</strong></p></blockquote><p><img src="https://picbed.octalzhihao.top/img/202503091240277.png" alt="image-20241019151041810" /></p><p>在训练好的词向量中可以发现一些词的词向量在连续空间中的一些关系。</p><p><img src="https://picbed.octalzhihao.top/img/202503091240278.png" alt="image-20241019151110555" /></p><p>恰好可以简单地理解成知识图谱中的关系（relation）、（Rome, is-capital-of, Italy）和（Paris, is-capital-of, France），可以看作是知识图谱中的三元组（triple），这对知识图谱的向量表示产生了一定的启发。</p><h3 id="253-知识图谱嵌入的概念"><a class="markdownIt-Anchor" href="#253-知识图谱嵌入的概念"></a> 2.5.3 知识图谱嵌入的概念</h3><p>为了解决前面提到的知识图谱表示的挑战，在词向量的启发下，研究者考虑如何将知识图谱中的实体和关系映射到连续的向量空间，并包含一些语义层面的信息，可以使得在下游任务中更加方便地操作知识图谱。</p><p>把这种将知识图谱中包括实体和关系的内容映射到连续向量空间方法的研究领域称为知识图谱嵌入（ Knowledge Graph Embedding ）、 知 识 图 谱 的 向 量 表 示 、 知 识 图 谱 的 表 示 学 习（Representation Learning）、知识表示学习。</p><p>类似于词向量，知识图谱嵌入也是通过机器学习的方法对模型进行学习，<strong>与独热编码、词袋模型的最大区别在于，知识图谱嵌入方法的训练需要基于监督学习</strong>。</p><p>类似于词向量，经典的知识图谱嵌入模型 <strong>TransE</strong> 的设计思想就是，如果一个三元组（<em>h</em>, <em>r</em>, <em>t</em>）成立，那么它们需要符合 <em>h</em>+<em>r</em> ≈ <em>t</em> 关系，例如：</p>]]></content>
      
      
      <categories>
          
          <category> 知识图谱 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识图谱 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决：安装了VMware Tools，但无法实现文件的拖拽和复制粘贴</title>
      <link href="/posts/15406.html"/>
      <url>/posts/15406.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文为新站建成后从旧博客搬运，原文地址：<a href="https://www.cnblogs.com/zhouzhihao/p/16486787.html">https://www.cnblogs.com/zhouzhihao/p/16486787.html</a><br />原文发表于2022-07-17 14:09<br />请注意时效性</p></blockquote><p>环境：Windows11，VMware16Pro，Ubuntu20.04</p><p>我给虚拟机装好Ubuntu系统后，它默认是安装好vmtools的。</p><p>而且这些选项默认是勾选的，但是我无法实现宿主机和虚拟机之间文件的拖拽和复制粘贴。</p><img src="https://picbed.octalzhihao.top/img/myblog/1591707071.png" width = "60%"><p>如果你遇到了和我一样的问题，且网上很多博文提供的解决方案都无法解决你的问题，那么请往下看</p><p>我试了各路大神的解决方案，基本都行不通。</p><p>只有一篇标题和这个问题相关度不高的文章，提到了一种重装VMware tools的方法，我试了一下终于解决了问题。</p><p>这里要说一下，网上的很多文章用cd里带的VMware tools压缩包来重新安装（还要手动输yes的那个方法），我试了，根本没有用。</p><p>毕竟初始安装的就是那个版本，再重新安装一下并没有意义。</p><p>真正的解决方案其实很方便：</p><p>打开终端</p><p>1.卸载VMware Tools</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get autoremove open-vm-tools</span><br></pre></td></tr></table></figure><p>2.联网安装VMware tools</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install open-vm-tools-desktop</span><br></pre></td></tr></table></figure><p>如果出错了，就执行下面两行命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install open-vm-tools-desktop fuse</span><br></pre></td></tr></table></figure><p>3.重启虚拟机即可</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用lambda表达式实现sort的自定义排序</title>
      <link href="/posts/32384.html"/>
      <url>/posts/32384.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>首先大致讲一下什么是lambda表达式：</p><p>你也可以将它就当做是匿名函数，lambda表达式其实就是匿名函数演化出的一种语法系统。</p><p>举个栗子：</p><p><strong>普通函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">function</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>;   <span class="comment">//声明（定义）</span></span><br><span class="line"><span class="built_in">function</span>(<span class="number">1</span>, <span class="number">2</span>);              <span class="comment">//调用</span></span><br></pre></td></tr></table></figure><p><strong>匿名函数（lambda表达式）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[](<span class="type">int</span> x, <span class="type">int</span> y)&#123;函数主体&#125;;          <span class="comment">//声明（定义）</span></span><br><span class="line">[](<span class="type">int</span> x, <span class="type">int</span> y)&#123;函数主体&#125;(<span class="number">1</span>, <span class="number">2</span>);    <span class="comment">//调用</span></span><br></pre></td></tr></table></figure><p>一个很明显的区别就是使用lambda表达式就省去了给函数命名的工作</p><p>而且对于一些简短的函数，直接用lambda表达式声明+调用能提高一点编码效率</p><p>就比如说，常用的自定义sort的比较函数。</p><hr /><p>关于lambda表达式如果想进一步了解：</p><p>使用Java的同学可以再读读廖老师这篇教程 -&gt; <a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1305158055100449">传送门</a></p><p>使用C++的同学可以读读这篇博客 -&gt; <a href="https://blog.csdn.net/Ezra521/article/details/113694743" title="传送门">传送门</a></p><hr /><p>如果我们用普通函数的写法来重载运算符</p><p>那么是这样写</p><p>(想了解更多，可以读读我的这篇文章 -&gt; <a href="https://www.cnblogs.com/zhouzhihao/p/10974594.html" title="传送门">传送门</a>)</p><p>正文开始</p><h2 id="c篇"><a class="markdownIt-Anchor" href="#c篇"></a> C++篇</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">15</span>]=&#123;<span class="number">0</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">7</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> x&gt;y;&#125;</span><br><span class="line"><span class="comment">//这样实现的是降序</span></span><br><span class="line"><span class="comment">//C++内部默认用的是&lt;实现sort，所以是升序</span></span><br><span class="line"><span class="comment">//比较函数的意义就在于将&lt;重载为&gt; </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">sort</span>(a, a<span class="number">+11</span>, cmp);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">10</span>;i++)</span><br><span class="line">cout&lt;&lt;a[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而用lambda表达式就可以这样写</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">15</span>]=&#123;<span class="number">0</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">7</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">sort</span>(a,a<span class="number">+11</span>,[](<span class="type">int</span> x,<span class="type">int</span> y)&#123;<span class="keyword">return</span> x&gt;y;&#125;);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">10</span>;i++)</span><br><span class="line">cout&lt;&lt;a[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样lambda表达式对vector也是适用的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">15</span>]=&#123;<span class="number">0</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">7</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; b;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> x : a) <span class="comment">//把a数组复制给b向量 </span></span><br><span class="line">b.<span class="built_in">push_back</span>(x);</span><br><span class="line"><span class="built_in">sort</span>(b.<span class="built_in">begin</span>(),b.<span class="built_in">end</span>(),[](<span class="type">int</span> x,<span class="type">int</span> y)&#123;<span class="keyword">return</span> x&gt;y;&#125; );</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">10</span>;i++)</span><br><span class="line">cout&lt;&lt;b[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大多数情况下，我们可能是针对pair或结构体来自定义比较函数<br />那么修改对应数据类型（结构体名）就ok了，类似这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">15</span>]=&#123;<span class="number">0</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">7</span>&#125;;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;pii&gt; b;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> x : a) <span class="comment">//把a数组复制给b向量 </span></span><br><span class="line">b.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(x,x<span class="number">+1</span>));</span><br><span class="line"><span class="built_in">sort</span>(b.<span class="built_in">begin</span>(),b.<span class="built_in">end</span>(),[](pii x,pii y)&#123;<span class="keyword">return</span> x.first&gt;y.first;&#125; );</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">10</span>;i++)</span><br><span class="line">cout&lt;&lt;b[i].second&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>补充一点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(b.<span class="built_in">begin</span>(),b.<span class="built_in">end</span>(),[](<span class="type">int</span> x,<span class="type">int</span> y)&#123;<span class="keyword">return</span> x&gt;y;&#125; );</span><br></pre></td></tr></table></figure><p>原本应该是这样的，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(b.<span class="built_in">begin</span>(),b.<span class="built_in">end</span>(),[](<span class="type">int</span> x,<span class="type">int</span> y) -&gt; <span class="type">bool</span> &#123;<span class="keyword">return</span> x&gt;y;&#125; );</span><br></pre></td></tr></table></figure><p>不过C++可以自动识别函数返回值得数据类型，所以可以简写。</p><h2 id="java篇"><a class="markdownIt-Anchor" href="#java篇"></a> Java篇</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现对a数组的降序排序</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        Integer[] a = &#123;<span class="number">0</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">7</span>&#125;;</span><br><span class="line">        Arrays.sort(a, (x,y) -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> y-x;<span class="comment">//此处实现的是降序</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++) </span><br><span class="line">&#123;</span><br><span class="line">System.out.printf(<span class="string">&quot;%d &quot;</span>,a[i]);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java的sort比较机制不同与C++</p><p>如果要实现降序就是后-前</p><p>升序就是前-后</p><p>此外，这样写也能实现降序（用内置compareTo函数）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(a, (x,y) -&gt; &#123;</span><br><span class="line">       <span class="keyword">return</span> y.compareTo(x);<span class="comment">//此处实现的是降序</span></span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure><p>反之，return x.compareTo(y); 就是升序。</p><p>因为只有一行语句，所以可以更简洁美观一点，直接省略花括号。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(a, (x,y) -&gt; y-x;);</span><br></pre></td></tr></table></figure><hr /><p>结构体方面，感觉java用起来没有C++舒服。</p><p>我们就通过这道经典的<a href="https://www.luogu.com.cn/problem/P1093" title="[NOIP2007 普及组] 奖学金">[NOIP2007 普及组] 奖学金</a>演示一遍Java的写法吧。</p><p>做这道题需要用到Java的类与接口</p><p><strong>朴素做法就是通过自定义一个class从而自定义compareTo来做</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">Student[] stu = <span class="keyword">new</span> <span class="title class_">Student</span>[n+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"><span class="type">int</span> <span class="variable">e</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">stu[i] = <span class="keyword">new</span> <span class="title class_">Student</span>(i, c, m, e, c+m+e);</span><br><span class="line">&#125;</span><br><span class="line">Arrays.sort(stu, <span class="number">1</span>, n+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++)</span><br><span class="line">System.out.println(stu[i].id+<span class="string">&quot; &quot;</span>+stu[i].tot);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Student&gt; </span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> c,m,e,id;<span class="comment">//语数英、学号</span></span><br><span class="line"><span class="type">int</span> tot;<span class="comment">//总分</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> id,<span class="type">int</span> c,<span class="type">int</span> m,<span class="type">int</span> e,<span class="type">int</span> tot)</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">this</span>.id=id;</span><br><span class="line"><span class="built_in">this</span>.c=c;</span><br><span class="line"><span class="built_in">this</span>.m=m;</span><br><span class="line"><span class="built_in">this</span>.e=e;</span><br><span class="line"><span class="built_in">this</span>.tot=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Student st)</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">this</span>.tot != st.tot) <span class="keyword">return</span> st.tot-<span class="built_in">this</span>.tot;</span><br><span class="line"><span class="comment">//因为是降序，所以是To后的那个数减前面的数</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">this</span>.c != st.c) <span class="keyword">return</span> st.c-<span class="built_in">this</span>.c;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.id-st.id;<span class="comment">//此处是升序</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过Java和C++的一个不同点是，<br /><strong>Java没有结构体</strong><br />而Java里定义一个类本身也就要求必须有compareTo<br />所以在本题中的这个Student类就没法自定义匿名比较函数。</p><p>当然这道题想用lambda表达式来简化代码，也是可以的。</p><p>因为Java里的数组也是对象，所以我们也可以对一个二维数组中进行sort，而lambda表达式也是可以针对数组对象的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">public class Main</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args) </span><br><span class="line">    &#123;</span><br><span class="line">    Scanner sc = new Scanner(System.in);</span><br><span class="line">    int n = sc.nextInt();</span><br><span class="line">    int[][] a = new int[n+5][6];</span><br><span class="line">    for(int i=1; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">    a[i][1] = i;</span><br><span class="line">    for(int j=2; j&lt;=4; j++)</span><br><span class="line">    &#123;</span><br><span class="line">    a[i][j] = sc.nextInt();</span><br><span class="line">    a[i][5] += a[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(a, 1, 1+n, (x,y)-&gt;&#123;</span><br><span class="line">    if(x[5] != y[5]) return y[5]-x[5];</span><br><span class="line">    if(x[2] != y[2]) return y[2]-x[2];</span><br><span class="line">    return x[1]-y[1];</span><br><span class="line">    &#125;);</span><br><span class="line">    for(int i=1; i&lt;=5; i++)</span><br><span class="line">    System.out.println(a[i][1]+&quot; &quot;+a[i][5]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样写，代码就简化很多了</p>]]></content>
      
      
      <categories>
          
          <category> 算法随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些提升Linux终端舒适度的配置</title>
      <link href="/posts/13601.html"/>
      <url>/posts/13601.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文为新站建成后从旧博客搬运，原文地址：<a href="https://www.cnblogs.com/zhouzhihao/p/17093067.html">https://www.cnblogs.com/zhouzhihao/p/17093067.html</a><br />原文发表于2023-02-07 15:49<br />请注意时效性</p></blockquote><h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>虽然现在许多IDE和文本编辑器都已支持了远程连接服务器的功能<br />但不得不说，在一个bash小黑框里用vim+tmux写代码也是一个很有逼格的事情<br />但说实话，默认配置下的vim还是很伤眼睛的🙃<br />于是我就花了些时间对三大配置文件进行了改造<br />今天把它们分享出来（也防止我以后换服务器的过程中弄丢😅<br />（收集自互联网，部分配置借鉴了其他博主）<br />大家也可以根据注释自行修改</p><h2 id="ps"><a class="markdownIt-Anchor" href="#ps"></a> PS</h2><ul><li>为图个方便，tmux的所有Ctrl+B都换成了Ctrl+A；tmux启用了鼠标</li><li>为图个页面简洁，我把当前路径前的<code>@主机名</code>部分去掉了</li><li>vim行高亮的背景色换成了黑色，但可以根据行号处的高亮来确定当前所处行</li><li>vim开启了()/{}/[]/‘’/“”/``的补全</li></ul><h1 id="vimrc"><a class="markdownIt-Anchor" href="#vimrc"></a> .vimrc</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br></pre></td><td class="code"><pre><span class="line">&quot; An example for a vimrc file.</span><br><span class="line">&quot;</span><br><span class="line">&quot; To use it, copy it to</span><br><span class="line">&quot;     for Unix and OS/2:  ~/.vimrc</span><br><span class="line">&quot;      for Amiga:  s:.vimrc</span><br><span class="line">&quot;  for MS-DOS and Win32:  $VIM\_vimrc</span><br><span class="line">&quot;    for OpenVMS:  sys$login:.vimrc</span><br><span class="line"></span><br><span class="line">&quot; When started as &quot;evim&quot;, evim.vim will already have done these settings.</span><br><span class="line">if v:progname =~? &quot;evim&quot;</span><br><span class="line">  finish</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">&quot; Use Vim settings, rather then Vi settings (much better!).</span><br><span class="line">&quot; This must be first, because it changes other options as a side effect.</span><br><span class="line">set nocompatible</span><br><span class="line"></span><br><span class="line">&quot; allow backspacing over everything in insert mode</span><br><span class="line">set backspace=indent,eol,start</span><br><span class="line"></span><br><span class="line">if has(&quot;vms&quot;)</span><br><span class="line">  set nobackup&quot; do not keep a backup file, use versions instead</span><br><span class="line">else</span><br><span class="line">  set backup&quot; keep a backup file</span><br><span class="line">endif</span><br><span class="line">set history=50&quot; keep 50 lines of command line history</span><br><span class="line">set ruler&quot; show the cursor position all the time</span><br><span class="line">set showcmd&quot; display incomplete commands</span><br><span class="line">set incsearch&quot; do incremental searching</span><br><span class="line"></span><br><span class="line">vmap &lt;leader&gt;y :w! /tmp/vitmp&lt;CR&gt;</span><br><span class="line">nmap &lt;leader&gt;p :r! cat /tmp/vitmp&lt;CR&gt;</span><br><span class="line"></span><br><span class="line">&quot;语法高亮</span><br><span class="line">syntax enable</span><br><span class="line">syntax on</span><br><span class="line">&quot;显示行号</span><br><span class="line">set nu</span><br><span class="line"></span><br><span class="line">&quot;修改默认注释颜色</span><br><span class="line">&quot;hi Comment ctermfg=DarkCyan</span><br><span class="line">&quot;允许退格键删除</span><br><span class="line">&quot;set backspace=2</span><br><span class="line">&quot;启用鼠标</span><br><span class="line">set mouse=a</span><br><span class="line">set selection=exclusive</span><br><span class="line">set selectmode=mouse,key</span><br><span class="line">&quot;按C语言格式缩进</span><br><span class="line">set cindent</span><br><span class="line">set autoindent</span><br><span class="line">set smartindent</span><br><span class="line">set shiftwidth=4</span><br><span class="line"></span><br><span class="line">&quot; 允许在有未保存的修改时切换缓冲区</span><br><span class="line">&quot;set hidden</span><br><span class="line"></span><br><span class="line">&quot; 设置无备份文件</span><br><span class="line">set writebackup</span><br><span class="line">set nobackup</span><br><span class="line"></span><br><span class="line">&quot;显示括号匹配</span><br><span class="line">set showmatch</span><br><span class="line">&quot;括号匹配显示时间为1(单位是十分之一秒)</span><br><span class="line">set matchtime=5</span><br><span class="line">&quot;显示当前的行号列号：</span><br><span class="line">set ruler</span><br><span class="line">&quot;在状态栏显示正在输入的命令</span><br><span class="line">set showcmd</span><br><span class="line"></span><br><span class="line">set foldmethod=syntax</span><br><span class="line">&quot;默认情况下不折叠</span><br><span class="line">set foldlevel=100</span><br><span class="line">&quot; 开启状态栏信息</span><br><span class="line">set laststatus=2</span><br><span class="line">&quot; 命令行的高度，默认为1，这里设为2</span><br><span class="line">set cmdheight=2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&quot; 显示Tab符，使用一高亮竖线代替</span><br><span class="line">set list</span><br><span class="line">&quot;set listchars=tab:\|\ ,</span><br><span class="line">set listchars=tab:&gt;-,trail:-</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&quot;侦测文件类型</span><br><span class="line">filetype on</span><br><span class="line">&quot;载入文件类型插件</span><br><span class="line">filetype plugin on</span><br><span class="line">&quot;为特定文件类型载入相关缩进文件</span><br><span class="line">filetype indent on</span><br><span class="line">&quot; 启用自动补全</span><br><span class="line">filetype plugin indent on </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&quot;设置编码自动识别, 中文引号显示</span><br><span class="line">filetype on &quot;打开文件类型检测</span><br><span class="line">&quot;set fileencodings=euc-cn,ucs-bom,utf-8,cp936,gb2312,gb18030,gbk,big5,euc-jp,euc-kr,latin1</span><br><span class="line">set fileencodings=utf-8,gb2312,gbk,gb18030</span><br><span class="line">&quot;这个用能很给劲，不管encoding是什么编码，都能将文本显示汉字</span><br><span class="line">&quot;set termencoding=gb2312</span><br><span class="line">set termencoding=utf-8</span><br><span class="line">&quot;新建文件使用的编码</span><br><span class="line">set fileencoding=utf-8</span><br><span class="line">&quot;set fileencoding=gb2312</span><br><span class="line">&quot;用于显示的编码，仅仅是显示</span><br><span class="line">set encoding=utf-8</span><br><span class="line">&quot;set encoding=utf-8</span><br><span class="line">&quot;set encoding=euc-cn</span><br><span class="line">&quot;set encoding=gbk</span><br><span class="line">&quot;set encoding=gb2312</span><br><span class="line">&quot;set ambiwidth=double</span><br><span class="line">set fileformat=unix</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&quot;设置高亮搜索</span><br><span class="line">set hlsearch</span><br><span class="line">&quot;在搜索时，输入的词句的逐字符高亮</span><br><span class="line">set incsearch</span><br><span class="line"></span><br><span class="line">&quot; 着色模式</span><br><span class="line">set t_Co=256</span><br><span class="line">&quot;colorscheme wombat256mod</span><br><span class="line">&quot;colorscheme gardener</span><br><span class="line">&quot;colorscheme elflord</span><br><span class="line">colorscheme desert</span><br><span class="line">&quot;colorscheme evening</span><br><span class="line">&quot;colorscheme darkblue</span><br><span class="line">&quot;colorscheme torte</span><br><span class="line">&quot;colorscheme default</span><br><span class="line"></span><br><span class="line">&quot; 字体 &amp;&amp; 字号</span><br><span class="line">set guifont=Monaco:h10</span><br><span class="line">&quot;set guifont=Consolas:h10</span><br><span class="line"></span><br><span class="line">&quot; :LoadTemplate       根据文件后缀自动加载模板</span><br><span class="line">&quot;let g:template_path=&#x27;/home/ruchee/.vim/template/&#x27;</span><br><span class="line"></span><br><span class="line">&quot; :AuthorInfoDetect   自动添加作者、时间等信息，本质是NERD_commenter &amp;&amp; authorinfo的结合</span><br><span class="line">&quot;&quot;let g:vimrc_author=&#x27;octal&#x27;</span><br><span class="line"></span><br><span class="line">&quot; Ctrl + E            一步加载语法模板和作者、时间信息</span><br><span class="line">&quot;&quot;map &lt;c-e&gt; &lt;ESC&gt;:AuthorInfoDetect&lt;CR&gt;&lt;ESC&gt;Gi</span><br><span class="line">&quot;&quot;imap &lt;c-e&gt; &lt;ESC&gt;:AuthorInfoDetect&lt;CR&gt;&lt;ESC&gt;Gi</span><br><span class="line">&quot;&quot;vmap &lt;c-e&gt; &lt;ESC&gt;:AuthorInfoDetect&lt;CR&gt;&lt;ESC&gt;Gi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&quot; ======= 引号 &amp;&amp; 括号自动匹配 ======= &quot;</span><br><span class="line"></span><br><span class="line">inoremap ( ()&lt;ESC&gt;i</span><br><span class="line"></span><br><span class="line">&quot;&quot;inoremap ) &lt;c-r&gt;=ClosePair(&#x27;)&#x27;)&lt;CR&gt;</span><br><span class="line"></span><br><span class="line">inoremap &#123; &#123;&#125;&lt;ESC&gt;i</span><br><span class="line"></span><br><span class="line">&quot;&quot;inoremap &#125; &lt;c-r&gt;=ClosePair(&#x27;&#125;&#x27;)&lt;CR&gt;</span><br><span class="line"></span><br><span class="line">inoremap [ []&lt;ESC&gt;i</span><br><span class="line"></span><br><span class="line">&quot;&quot;inoremap ] &lt;c-r&gt;=ClosePair(&#x27;]&#x27;)&lt;CR&gt;</span><br><span class="line"></span><br><span class="line">&quot;&quot;inoremap &lt; &lt;&gt;&lt;ESC&gt;i</span><br><span class="line"></span><br><span class="line">&quot;&quot;inoremap &gt; &lt;c-r&gt;=ClosePair(&#x27;&gt;&#x27;)&lt;CR&gt;</span><br><span class="line"></span><br><span class="line">inoremap &quot; &quot;&quot;&lt;ESC&gt;i</span><br><span class="line"></span><br><span class="line">inoremap &#x27; &#x27;&#x27;&lt;ESC&gt;i</span><br><span class="line"></span><br><span class="line">inoremap ` ``&lt;ESC&gt;i</span><br><span class="line"></span><br><span class="line">&quot;&quot;inoremap * **&lt;ESC&gt;i</span><br><span class="line"></span><br><span class="line">&quot; 每行超过80个的字符用下划线标示</span><br><span class="line">&quot;&quot;au BufRead,BufNewFile *.s,*.asm,*.h,*.c,*.cpp,*.java,*.cs,*.lisp,*.el,*.erl,*.tex,*.sh,*.lua,*.pl,*.php,*.tpl,*.py,*.rb,*.erb,*.vim,*.js,*.jade,*.coffee,*.css,*.xml,*.html,*.shtml,*.xhtml Underlined /.\%81v/</span><br><span class="line">&quot;</span><br><span class="line">&quot;</span><br><span class="line">&quot; For Win32 GUI: remove &#x27;t&#x27; flag from &#x27;guioptions&#x27;: no tearoff menu entries</span><br><span class="line">&quot; let &amp;guioptions = substitute(&amp;guioptions, &quot;t&quot;, &quot;&quot;, &quot;g&quot;)</span><br><span class="line"></span><br><span class="line">&quot; Don&#x27;t use Ex mode, use Q for formatting</span><br><span class="line">map Q gq</span><br><span class="line"></span><br><span class="line">&quot; This is an alternative that also works in block mode, but the deleted</span><br><span class="line">&quot; text is lost and it only works for putting the current register.</span><br><span class="line">&quot;vnoremap p &quot;_dp</span><br><span class="line"></span><br><span class="line">&quot; Switch syntax highlighting on, when the terminal has colors</span><br><span class="line">&quot; Also switch on highlighting the last used search pattern.</span><br><span class="line">if &amp;t_Co &gt; 2 || has(&quot;gui_running&quot;)</span><br><span class="line">  syntax on</span><br><span class="line">  set hlsearch</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">&quot; Only do this part when compiled with support for autocommands.</span><br><span class="line">if has(&quot;autocmd&quot;)</span><br><span class="line"></span><br><span class="line">  &quot; Enable file type detection.</span><br><span class="line">  &quot; Use the default filetype settings, so that mail gets &#x27;tw&#x27; set to 72,</span><br><span class="line">  &quot; &#x27;cindent&#x27; is on in C files, etc.</span><br><span class="line">  &quot; Also load indent files, to automatically do language-dependent indenting.</span><br><span class="line">  filetype plugin indent on</span><br><span class="line"></span><br><span class="line">  &quot; Put these in an autocmd group, so that we can delete them easily.</span><br><span class="line">  augroup vimrcEx</span><br><span class="line">  au!</span><br><span class="line"></span><br><span class="line">  &quot; For all text files set &#x27;textwidth&#x27; to 80 characters.</span><br><span class="line">  autocmd FileType text setlocal textwidth=80</span><br><span class="line"></span><br><span class="line">  &quot; When editing a file, always jump to the last known cursor position.</span><br><span class="line">  &quot; Don&#x27;t do it when the position is invalid or when inside an event handler</span><br><span class="line">  &quot; (happens when dropping a file on gvim).</span><br><span class="line">  autocmd BufReadPost *</span><br><span class="line">    \ if line(&quot;&#x27;\&quot;&quot;) &gt; 0 &amp;&amp; line(&quot;&#x27;\&quot;&quot;) &lt;= line(&quot;$&quot;) |</span><br><span class="line">    \   exe &quot;normal g`\&quot;&quot; |</span><br><span class="line">    \ endif</span><br><span class="line"></span><br><span class="line">  augroup END</span><br><span class="line"></span><br><span class="line">else</span><br><span class="line"></span><br><span class="line">  set autoindent&quot; always set autoindenting on</span><br><span class="line"></span><br><span class="line">endif &quot; has(&quot;autocmd&quot;)</span><br><span class="line"></span><br><span class="line">&quot; 增加鼠标行高亮</span><br><span class="line">set cursorline</span><br><span class="line">hi CursorLine  cterm=NONE   ctermbg=black</span><br><span class="line">&quot;&quot;ctermfg=white</span><br><span class="line"></span><br><span class="line">&quot; 设置tab是四个空格</span><br><span class="line">set ts=4</span><br><span class="line">set expandtab</span><br><span class="line"></span><br><span class="line">&quot;左右方向键实现换行</span><br><span class="line">set whichwrap+=&lt;,&gt;,[,]</span><br><span class="line"></span><br><span class="line">&quot;在命令模式下，按下tab可以自动补全命令</span><br><span class="line">set wildmenu</span><br><span class="line">set wildmode=longest,list,full</span><br><span class="line"></span><br><span class="line">&quot; 主要给Tlist使用</span><br><span class="line">let Tlist_Exit_OnlyWindow = 1</span><br><span class="line">let Tlist_Auto_Open = 1</span><br></pre></td></tr></table></figure><h1 id="bashrc"><a class="markdownIt-Anchor" href="#bashrc"></a> .bashrc</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"># ~/.bashrc: executed by bash(1) for non-login shells.</span><br><span class="line"># see /usr/share/doc/bash/examples/startup-files (in the package bash-doc)</span><br><span class="line"># for examples</span><br><span class="line"></span><br><span class="line"># If not running interactively, don&#x27;t do anything</span><br><span class="line">case $- in</span><br><span class="line">    *i*) ;;</span><br><span class="line">      *) return;;</span><br><span class="line">esac</span><br><span class="line"></span><br><span class="line"># don&#x27;t put duplicate lines or lines starting with space in the history.</span><br><span class="line"># See bash(1) for more options</span><br><span class="line">HISTCONTROL=ignoreboth</span><br><span class="line"></span><br><span class="line"># append to the history file, don&#x27;t overwrite it</span><br><span class="line">shopt -s histappend</span><br><span class="line"></span><br><span class="line"># for setting history length see HISTSIZE and HISTFILESIZE in bash(1)</span><br><span class="line">HISTSIZE=1000</span><br><span class="line">HISTFILESIZE=2000</span><br><span class="line"></span><br><span class="line"># check the window size after each command and, if necessary,</span><br><span class="line"># update the values of LINES and COLUMNS.</span><br><span class="line">shopt -s checkwinsize</span><br><span class="line"></span><br><span class="line"># If set, the pattern &quot;**&quot; used in a pathname expansion context will</span><br><span class="line"># match all files and zero or more directories and subdirectories.</span><br><span class="line">#shopt -s globstar</span><br><span class="line"></span><br><span class="line"># make less more friendly for non-text input files, see lesspipe(1)</span><br><span class="line">[ -x /usr/bin/lesspipe ] &amp;&amp; eval &quot;$(SHELL=/bin/sh lesspipe)&quot;</span><br><span class="line"></span><br><span class="line"># set variable identifying the chroot you work in (used in the prompt below)</span><br><span class="line">if [ -z &quot;$&#123;debian_chroot:-&#125;&quot; ] &amp;&amp; [ -r /etc/debian_chroot ]; then</span><br><span class="line">    debian_chroot=$(cat /etc/debian_chroot)</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># set a fancy prompt (non-color, unless we know we &quot;want&quot; color)</span><br><span class="line">case &quot;$TERM&quot; in</span><br><span class="line">    xterm-color|*-256color) color_prompt=yes;;</span><br><span class="line">esac</span><br><span class="line"></span><br><span class="line"># uncomment for a colored prompt, if the terminal has the capability; turned</span><br><span class="line"># off by default to not distract the user: the focus in a terminal window</span><br><span class="line"># should be on the output of commands, not on the prompt</span><br><span class="line">#force_color_prompt=yes</span><br><span class="line"></span><br><span class="line">if [ -n &quot;$force_color_prompt&quot; ]; then</span><br><span class="line">    if [ -x /usr/bin/tput ] &amp;&amp; tput setaf 1 &gt;&amp;/dev/null; then</span><br><span class="line"># We have color support; assume it&#x27;s compliant with Ecma-48</span><br><span class="line"># (ISO/IEC-6429). (Lack of such support is extremely rare, and such</span><br><span class="line"># a case would tend to support setf rather than setaf.)</span><br><span class="line">color_prompt=yes</span><br><span class="line">    else</span><br><span class="line">color_prompt=</span><br><span class="line">    fi</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ &quot;$color_prompt&quot; = yes ]; then</span><br><span class="line">    #PS1=&#x27;$&#123;debian_chroot:+($debian_chroot)&#125;\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ &#x27;</span><br><span class="line">    PS1=&#x27;$&#123;debian_chroot:+($debian_chroot)&#125;\[\033[01;32m\]\u\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ &#x27;</span><br><span class="line">else</span><br><span class="line">    #PS1=&#x27;$&#123;debian_chroot:+($debian_chroot)&#125;\u@\h:\w\$ &#x27;</span><br><span class="line">     PS1=&#x27;$&#123;debian_chroot:+($debian_chroot)&#125;\u: \w\$ &#x27;</span><br><span class="line">fi</span><br><span class="line">unset color_prompt force_color_prompt</span><br><span class="line"></span><br><span class="line"># If this is an xterm set the title to user@host:dir</span><br><span class="line">case &quot;$TERM&quot; in</span><br><span class="line">xterm*|rxvt*)</span><br><span class="line">    #PS1=&quot;\[\e]0;$&#123;debian_chroot:+($debian_chroot)&#125;\u@\h: \w\a\]$PS1&quot;</span><br><span class="line">     PS1=&quot;\[\e]0;$&#123;debian_chroot:+($debian_chroot)&#125;\u: \w\a\]$PS1&quot;</span><br><span class="line">    ;;</span><br><span class="line">*)</span><br><span class="line">    ;;</span><br><span class="line">esac</span><br><span class="line"></span><br><span class="line"># enable color support of ls and also add handy aliases</span><br><span class="line">if [ -x /usr/bin/dircolors ]; then</span><br><span class="line">    test -r ~/.dircolors &amp;&amp; eval &quot;$(dircolors -b ~/.dircolors)&quot; || eval &quot;$(dircolors -b)&quot;</span><br><span class="line">    alias ls=&#x27;ls --color=auto&#x27;</span><br><span class="line">    #alias dir=&#x27;dir --color=auto&#x27;</span><br><span class="line">    #alias vdir=&#x27;vdir --color=auto&#x27;</span><br><span class="line"></span><br><span class="line">    alias grep=&#x27;grep --color=auto&#x27;</span><br><span class="line">    alias fgrep=&#x27;fgrep --color=auto&#x27;</span><br><span class="line">    alias egrep=&#x27;egrep --color=auto&#x27;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># colored GCC warnings and errors</span><br><span class="line">#export GCC_COLORS=&#x27;error=01;31:warning=01;35:note=01;36:caret=01;32:locus=01:quote=01&#x27;</span><br><span class="line"></span><br><span class="line"># some more ls aliases</span><br><span class="line">alias ll=&#x27;ls -alF&#x27;</span><br><span class="line">alias la=&#x27;ls -A&#x27;</span><br><span class="line">alias l=&#x27;ls -CF&#x27;</span><br><span class="line"></span><br><span class="line"># Add an &quot;alert&quot; alias for long running commands.  Use like so:</span><br><span class="line">#   sleep 10; alert</span><br><span class="line">alias alert=&#x27;notify-send --urgency=low -i &quot;$([ $? = 0 ] &amp;&amp; echo terminal || echo error)&quot; &quot;$(history|tail -n1|sed -e &#x27;\&#x27;&#x27;s/^\s*[0-9]\+\s*//;s/[;&amp;|]\s*alert$//&#x27;\&#x27;&#x27;)&quot;&#x27;</span><br><span class="line"></span><br><span class="line"># Alias definitions.</span><br><span class="line"># You may want to put all your additions into a separate file like</span><br><span class="line"># ~/.bash_aliases, instead of adding them here directly.</span><br><span class="line"># See /usr/share/doc/bash-doc/examples in the bash-doc package.</span><br><span class="line"></span><br><span class="line">if [ -f ~/.bash_aliases ]; then</span><br><span class="line">    . ~/.bash_aliases</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># enable programmable completion features (you don&#x27;t need to enable</span><br><span class="line"># this, if it&#x27;s already enabled in /etc/bash.bashrc and /etc/profile</span><br><span class="line"># sources /etc/bash.bashrc).</span><br><span class="line">if ! shopt -oq posix; then</span><br><span class="line">  if [ -f /usr/share/bash-completion/bash_completion ]; then</span><br><span class="line">    . /usr/share/bash-completion/bash_completion</span><br><span class="line">  elif [ -f /etc/bash_completion ]; then</span><br><span class="line">    . /etc/bash_completion</span><br><span class="line">  fi</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">export PATH=/home/acs/.homework:$PATH</span><br><span class="line">alias tmux=&#x27;tmux -u&#x27;</span><br></pre></td></tr></table></figure><h1 id="tmuxconf"><a class="markdownIt-Anchor" href="#tmuxconf"></a> .tmux.conf</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">set-option -g status-keys vi</span><br><span class="line">setw -g mode-keys vi</span><br><span class="line"></span><br><span class="line">setw -g monitor-activity on</span><br><span class="line"></span><br><span class="line"># setw -g c0-change-trigger 10</span><br><span class="line"># setw -g c0-change-interval 100</span><br><span class="line"></span><br><span class="line"># setw -g c0-change-interval 50</span><br><span class="line"># setw -g c0-change-trigger  75</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">set-window-option -g automatic-rename on</span><br><span class="line">set-option -g set-titles on</span><br><span class="line">set -g history-limit 100000</span><br><span class="line"></span><br><span class="line">#set-window-option -g utf8 on</span><br><span class="line"></span><br><span class="line"># set command prefix</span><br><span class="line">set-option -g prefix C-a</span><br><span class="line">unbind-key C-b</span><br><span class="line">bind-key C-a send-prefix</span><br><span class="line"></span><br><span class="line">bind h select-pane -L</span><br><span class="line">bind j select-pane -D</span><br><span class="line">bind k select-pane -U</span><br><span class="line">bind l select-pane -R</span><br><span class="line"></span><br><span class="line">bind -n M-Left select-pane -L</span><br><span class="line">bind -n M-Right select-pane -R</span><br><span class="line">bind -n M-Up select-pane -U</span><br><span class="line">bind -n M-Down select-pane -D</span><br><span class="line"></span><br><span class="line">bind &lt; resize-pane -L 7</span><br><span class="line">bind &gt; resize-pane -R 7</span><br><span class="line">bind - resize-pane -D 7</span><br><span class="line">bind + resize-pane -U 7</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bind-key -n M-l next-window</span><br><span class="line">bind-key -n M-h previous-window</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">set -g status-interval 1</span><br><span class="line"># status bar</span><br><span class="line">set -g status-bg black</span><br><span class="line">set -g status-fg blue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#set -g status-utf8 on</span><br><span class="line">set -g status-justify centre</span><br><span class="line">set -g status-bg default</span><br><span class="line">set -g status-left &quot; #[fg=green]#S@#H #[default]&quot;</span><br><span class="line">set -g status-left-length 20</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># mouse support</span><br><span class="line"># for tmux 2.1</span><br><span class="line"># set -g mouse-utf8 on</span><br><span class="line">set -g mouse on</span><br><span class="line">#</span><br><span class="line"># for previous version</span><br><span class="line">#set -g mode-mouse on</span><br><span class="line">#set -g mouse-resize-pane on</span><br><span class="line">#set -g mouse-select-pane on</span><br><span class="line">#set -g mouse-select-window on</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#set -g status-right-length 25</span><br><span class="line">set -g status-right &quot;#[fg=green]%H:%M:%S #[fg=magenta]%a %m-%d #[default]&quot;</span><br><span class="line"></span><br><span class="line"># fix for tmux 1.9</span><br><span class="line">bind &#x27;&quot;&#x27; split-window -vc &quot;#&#123;pane_current_path&#125;&quot;</span><br><span class="line">bind &#x27;%&#x27; split-window -hc &quot;#&#123;pane_current_path&#125;&quot;</span><br><span class="line">bind &#x27;c&#x27; new-window -c &quot;#&#123;pane_current_path&#125;&quot;</span><br><span class="line"></span><br><span class="line"># run-shell &quot;powerline-daemon -q&quot;</span><br><span class="line"></span><br><span class="line"># vim: ft=conf</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> terminal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决：powershell无法使用ssh-copy-id命令</title>
      <link href="/posts/15639.html"/>
      <url>/posts/15639.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文为新站建成后从旧博客搬运，原文地址：<a href="https://www.cnblogs.com/zhouzhihao/p/17087666.html">https://www.cnblogs.com/zhouzhihao/p/17087666.html</a><br />原文发表于2023-02-02 22:46<br />请注意时效性</p></blockquote><p>如果你在配置服务器的免密登陆时出现了如下的error，那这篇文章一定会对你有帮助</p><p><img src="https://picbed.octalzhihao.top/img/myblog/1504700.png" alt="image" /></p><p>（zzh是我配置的别名，如果没有配置过，后面跟的参数应该是<code>用户名@ip地址</code>的格式）</p><p>报错的原因呢，其实是Windows终端和Linux终端不同，没有内置<code>ssh-copy-id</code>命令</p><p>本文提供三种解决方案</p><p>正常情况下，用第一种就可以解决了，而且第一种方案也最方便</p><h2 id="方案一-复制下面这段脚本粘贴到windows终端按回车运行即可"><a class="markdownIt-Anchor" href="#方案一-复制下面这段脚本粘贴到windows终端按回车运行即可"></a> 方案一 复制下面这段脚本，粘贴到Windows终端，按回车运行即可</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function ssh-copy-id([string]$userAtMachine, $args)&#123;   </span><br><span class="line">    $publicKey = &quot;$ENV:USERPROFILE&quot; + &quot;/.ssh/id_rsa.pub&quot;</span><br><span class="line">    if (!(Test-Path &quot;$publicKey&quot;))&#123;</span><br><span class="line">        Write-Error &quot;ERROR: failed to open ID file &#x27;$publicKey&#x27;: No such file&quot;            </span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        &amp; cat &quot;$publicKey&quot; | ssh $args $userAtMachine &quot;umask 077; test -d .ssh || mkdir .ssh ; cat &gt;&gt; .ssh/authorized_keys || exit 1&quot;      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样以后，就可以成功使用<code>ssh-copy-id</code>了</p><p>上面这段其实就是，根据<code>ssh-copy-id</code>的执行逻辑来编写的shell脚本</p><h2 id="方案二下载一个git-bash"><a class="markdownIt-Anchor" href="#方案二下载一个git-bash"></a> 方案二：下载一个git bash</h2><p>git bash是肯定可以有<code>ssh-copy-id</code>命令的，直接用就好了。</p><p>顺便提一句，如果还是不行，可能是没有<code>ssh-keygen</code>生成密钥。</p><p><img src="https://picbed.octalzhihao.top/img/myblog/1504701.png" alt="image" /></p><p><br><br></p><h2 id="方案三-最本质的做法"><a class="markdownIt-Anchor" href="#方案三-最本质的做法"></a> 方案三 最本质的做法</h2><p>ssh-copy-id的本质是把你本地的公钥添加到服务器/远程机的<code>~/.ssh/authorized_keys</code>文件里</p><p>powershell不给力，那我们自己Ctrl CV就好了<br /><code>ssh-keygen</code>生成密钥后，家目录/.ssh就会多两个文件</p><ul><li><code>id_rsa</code>：私钥</li><li><code>id_rsa.pub</code>：公钥</li></ul><ul><li><p>第一步<br />我们<code>cd .ssh</code><br />然后<code>cat .\id_rsa.pub</code><br />再把内容复制</p></li><li><p>第二步<br />ssh到自己的服务器<br />在<code>~/.ssh/</code>目录创建authorized_keys<br />通过vim把剪切板的内容粘贴到该文件即可</p></li></ul><p>下次登陆就不需要输入密码啦！</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> terminal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql学习笔记</title>
      <link href="/posts/51482.html"/>
      <url>/posts/51482.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本篇摘录自黑马程序员的B站教学视频。<br />本笔记只记录到进阶篇（大部分），剩下的进阶篇以及运维篇由于本人职业生涯没有用武之地，所以没有进行学习。</p><footer><strong>黑马程序员</strong><cite><a href="https://www.bilibili.com/video/BV1Kr4y1i7ru/?share_source=copy_web&vd_source=e43c1de8e41e1499f7f3fdb03fba0eb6">黑马程序员 MySQL数据库入门到精通，从mysql安装到mysql高级、mysql优化全囊括</a></cite></footer></blockquote><span id="more"></span><h1 id="基础篇"><a class="markdownIt-Anchor" href="#基础篇"></a> 基础篇</h1><h2 id="通用语法及分类"><a class="markdownIt-Anchor" href="#通用语法及分类"></a> 通用语法及分类</h2><ul><li>DDL: 数据定义语言，用来定义数据库对象（数据库、表、字段）</li><li>DML: 数据操作语言，用来对数据库表中的数据进行增删改</li><li>DQL: 数据查询语言，用来查询数据库中表的记录</li><li>DCL: 数据控制语言，用来创建数据库用户、控制数据库的控制权限</li></ul><h3 id="ddl数据定义语言"><a class="markdownIt-Anchor" href="#ddl数据定义语言"></a> DDL（数据定义语言）</h3><p>数据定义语言</p><h4 id="数据库操作"><a class="markdownIt-Anchor" href="#数据库操作"></a> 数据库操作</h4><p>查询所有数据库：<br /><code>SHOW DATABASES;</code><br />查询当前数据库：<br /><code>SELECT DATABASE();</code><br />创建数据库：<br /><code>CREATE DATABASE [ IF NOT EXISTS ] 数据库名 [ DEFAULT CHARSET 字符集] [COLLATE 排序规则 ];</code><br />删除数据库：<br /><code>DROP DATABASE [ IF EXISTS ] 数据库名;</code><br />使用数据库：<br /><code>USE 数据库名;</code></p><h5 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项"></a> 注意事项</h5><ul><li>UTF8字符集长度为3字节，有些符号占4字节，所以推荐用utf8mb4字符集</li></ul><h4 id="表操作"><a class="markdownIt-Anchor" href="#表操作"></a> 表操作</h4><p>查询当前数据库所有表：<br /><code>SHOW TABLES;</code><br />查询表结构：<br /><code>DESC 表名;</code><br />查询指定表的建表语句：<br /><code>SHOW CREATE TABLE 表名;</code></p><p>创建表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">字段1 字段1类型 [COMMENT 字段1注释],</span><br><span class="line">字段2 字段2类型 [COMMENT 字段2注释],</span><br><span class="line">字段3 字段3类型 [COMMENT 字段3注释],</span><br><span class="line">...</span><br><span class="line">字段n 字段n类型 [COMMENT 字段n注释]</span><br><span class="line">)[ COMMENT 表注释 ];</span><br></pre></td></tr></table></figure><p><strong>最后一个字段后面没有逗号</strong></p><p>添加字段：<br /><code>ALTER TABLE 表名 ADD 字段名 类型(长度) [COMMENT 注释] [约束];</code><br />例：<code>ALTER TABLE emp ADD nickname varchar(20) COMMENT '昵称';</code></p><p>修改数据类型：<br /><code>ALTER TABLE 表名 MODIFY 字段名 新数据类型(长度);</code><br />修改字段名和字段类型：<br /><code>ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释] [约束];</code><br />例：将emp表的nickname字段修改为username，类型为varchar(30)<br /><code>ALTER TABLE emp CHANGE nickname username varchar(30) COMMENT '昵称';</code></p><p>删除字段：<br /><code>ALTER TABLE 表名 DROP 字段名;</code></p><p>修改表名：<br /><code>ALTER TABLE 表名 RENAME TO 新表名</code></p><p>删除表：<br /><code>DROP TABLE [IF EXISTS] 表名;</code><br />删除表，并重新创建该表：<br /><code>TRUNCATE TABLE 表名;</code></p><h3 id="dml数据操作语言"><a class="markdownIt-Anchor" href="#dml数据操作语言"></a> DML（数据操作语言）</h3><h4 id="添加数据"><a class="markdownIt-Anchor" href="#添加数据"></a> 添加数据</h4><p>指定字段：<br /><code>INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...);</code><br />全部字段：<br /><code>INSERT INTO 表名 VALUES (值1, 值2, ...);</code></p><p>批量添加数据：<br /><code>INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...);</code><br /><code>INSERT INTO 表名 VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...);</code></p><h5 id="注意事项-2"><a class="markdownIt-Anchor" href="#注意事项-2"></a> 注意事项</h5><ul><li>字符串和日期类型数据应该包含在引号中</li><li>插入的数据大小应该在字段的规定范围内</li></ul><h4 id="更新和删除数据"><a class="markdownIt-Anchor" href="#更新和删除数据"></a> 更新和删除数据</h4><p>修改数据：<br /><code>UPDATE 表名 SET 字段名1 = 值1, 字段名2 = 值2, ... [ WHERE 条件 ];</code><br />例：<br /><code>UPDATE emp SET name = 'Jack' WHERE id = 1;</code></p><p>删除数据：<br /><code>DELETE FROM 表名 [ WHERE 条件 ];</code></p><h3 id="dql数据查询语言"><a class="markdownIt-Anchor" href="#dql数据查询语言"></a> DQL（数据查询语言）</h3><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">字段列表</span><br><span class="line">FROM</span><br><span class="line">表名字段</span><br><span class="line">WHERE</span><br><span class="line">条件列表</span><br><span class="line">GROUP BY</span><br><span class="line">分组字段列表</span><br><span class="line">HAVING</span><br><span class="line">分组后的条件列表</span><br><span class="line">ORDER BY</span><br><span class="line">排序字段列表</span><br><span class="line">LIMIT</span><br><span class="line">分页参数</span><br></pre></td></tr></table></figure><h4 id="基础查询"><a class="markdownIt-Anchor" href="#基础查询"></a> 基础查询</h4><p>查询多个字段：<br /><code>SELECT 字段1, 字段2, 字段3, ... FROM 表名;</code><br /><code>SELECT * FROM 表名;</code></p><p>设置别名：<br /><code>SELECT 字段1 [ AS 别名1 ], 字段2 [ AS 别名2 ], 字段3 [ AS 别名3 ], ... FROM 表名;</code><br /><code>SELECT 字段1 [ 别名1 ], 字段2 [ 别名2 ], 字段3 [ 别名3 ], ... FROM 表名;</code></p><p>去除重复记录：<br /><code>SELECT DISTINCT 字段列表 FROM 表名;</code></p><p>转义：<br /><code>SELECT * FROM 表名 WHERE name LIKE '/_张三' ESCAPE '/'</code><br />/ 之后的_不作为通配符</p><h4 id="条件查询"><a class="markdownIt-Anchor" href="#条件查询"></a> 条件查询</h4><p>语法：<br /><code>SELECT 字段列表 FROM 表名 WHERE 条件列表;</code></p><p>条件：</p><table><thead><tr><th>比较运算符</th><th>功能</th></tr></thead><tbody><tr><td>&gt;</td><td>大于</td></tr><tr><td>&gt;=</td><td>大于等于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&lt;=</td><td>小于等于</td></tr><tr><td>=</td><td>等于</td></tr><tr><td>&lt;&gt; 或 !=</td><td>不等于</td></tr><tr><td>BETWEEN … AND …</td><td>在某个范围内（含最小、最大值）</td></tr><tr><td>IN(…)</td><td>在in之后的列表中的值，多选一</td></tr><tr><td>LIKE 占位符</td><td>模糊匹配（_匹配单个字符，%匹配任意个字符）</td></tr><tr><td>IS NULL</td><td>是NULL</td></tr></tbody></table><table><thead><tr><th>逻辑运算符</th><th>功能</th></tr></thead><tbody><tr><td>AND 或 &amp;&amp;</td><td>并且（多个条件同时成立）</td></tr><tr><td>OR 或 ||</td><td>或者（多个条件任意一个成立）</td></tr><tr><td>NOT 或 !</td><td>非，不是</td></tr></tbody></table><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">-- 年龄等于30</span><br><span class="line">select * from employee where age = 30;</span><br><span class="line">-- 年龄小于30</span><br><span class="line">select * from employee where age &lt; 30;</span><br><span class="line">-- 小于等于</span><br><span class="line">select * from employee where age &lt;= 30;</span><br><span class="line">-- 没有身份证</span><br><span class="line">select * from employee where idcard is null or idcard = &#x27;&#x27;;</span><br><span class="line">-- 有身份证</span><br><span class="line">select * from employee where idcard;</span><br><span class="line">select * from employee where idcard is not null;</span><br><span class="line">-- 不等于</span><br><span class="line">select * from employee where age != 30;</span><br><span class="line">-- 年龄在20到30之间</span><br><span class="line">select * from employee where age between 20 and 30;</span><br><span class="line">select * from employee where age &gt;= 20 and age &lt;= 30;</span><br><span class="line">-- 下面语句不报错，但查不到任何信息</span><br><span class="line">select * from employee where age between 30 and 20;</span><br><span class="line">-- 性别为女且年龄小于30</span><br><span class="line">select * from employee where age &lt; 30 and gender = &#x27;女&#x27;;</span><br><span class="line">-- 年龄等于25或30或35</span><br><span class="line">select * from employee where age = 25 or age = 30 or age = 35;</span><br><span class="line">select * from employee where age in (25, 30, 35);</span><br><span class="line">-- 姓名为两个字</span><br><span class="line">select * from employee where name like &#x27;__&#x27;;</span><br><span class="line">-- 身份证最后为X</span><br><span class="line">select * from employee where idcard like &#x27;%X&#x27;;</span><br></pre></td></tr></table></figure><h4 id="聚合查询聚合函数"><a class="markdownIt-Anchor" href="#聚合查询聚合函数"></a> 聚合查询（聚合函数）</h4><p>常见聚合函数：</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>count</td><td>统计数量</td></tr><tr><td>max</td><td>最大值</td></tr><tr><td>min</td><td>最小值</td></tr><tr><td>avg</td><td>平均值</td></tr><tr><td>sum</td><td>求和</td></tr></tbody></table><p>语法：<br /><code>SELECT 聚合函数(字段列表) FROM 表名;</code><br />例：<br /><code>SELECT count(id) from employee where workaddress = &quot;广东省&quot;;</code></p><h4 id="分组查询"><a class="markdownIt-Anchor" href="#分组查询"></a> 分组查询</h4><p>语法：<br /><code>SELECT 字段列表 FROM 表名 [ WHERE 条件 ] GROUP BY 分组字段名 [ HAVING 分组后的过滤条件 ];</code></p><p>where 和 having 的区别：</p><ul><li>执行时机不同：where是分组之前进行过滤，不满足where条件不参与分组；having是分组后对结果进行过滤。</li><li>判断条件不同：where不能对聚合函数进行判断，而having可以。</li></ul><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-- 根据性别分组，统计男性和女性数量（只显示分组数量，不显示哪个是男哪个是女）</span><br><span class="line">select count(*) from employee group by gender;</span><br><span class="line">-- 根据性别分组，统计男性和女性数量</span><br><span class="line">select gender, count(*) from employee group by gender;</span><br><span class="line">-- 根据性别分组，统计男性和女性的平均年龄</span><br><span class="line">select gender, avg(age) from employee group by gender;</span><br><span class="line">-- 年龄小于45，并根据工作地址分组</span><br><span class="line">select workaddress, count(*) from employee where age &lt; 45 group by workaddress;</span><br><span class="line">-- 年龄小于45，并根据工作地址分组，获取员工数量大于等于3的工作地址</span><br><span class="line">select workaddress, count(*) address_count from employee where age &lt; 45 group by workaddress having address_count &gt;= 3;</span><br></pre></td></tr></table></figure><h5 id="注意事项-3"><a class="markdownIt-Anchor" href="#注意事项-3"></a> 注意事项</h5><ul><li>执行顺序：where &gt; 聚合函数 &gt; having</li><li>分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义</li></ul><h4 id="排序查询"><a class="markdownIt-Anchor" href="#排序查询"></a> 排序查询</h4><p>语法：<br /><code>SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1, 字段2 排序方式2;</code></p><p>排序方式：</p><ul><li>ASC: 升序（默认）</li><li>DESC: 降序</li></ul><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 根据年龄升序排序</span><br><span class="line">SELECT * FROM employee ORDER BY age ASC;</span><br><span class="line">SELECT * FROM employee ORDER BY age;</span><br><span class="line">-- 两字段排序，根据年龄升序排序，入职时间降序排序</span><br><span class="line">SELECT * FROM employee ORDER BY age ASC, entrydate DESC;</span><br></pre></td></tr></table></figure><h5 id="注意事项-4"><a class="markdownIt-Anchor" href="#注意事项-4"></a> 注意事项</h5><p>如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序</p><h4 id="分页查询"><a class="markdownIt-Anchor" href="#分页查询"></a> 分页查询</h4><p>语法：<br /><code>SELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询记录数;</code></p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 查询第一页数据，展示10条</span><br><span class="line">SELECT * FROM employee LIMIT 0, 10;</span><br><span class="line">-- 查询第二页</span><br><span class="line">SELECT * FROM employee LIMIT 10, 10;</span><br></pre></td></tr></table></figure><h5 id="注意事项-5"><a class="markdownIt-Anchor" href="#注意事项-5"></a> 注意事项</h5><ul><li>起始索引从0开始，起始索引 = （查询页码 - 1） * 每页显示记录数</li><li>分页查询是数据库的方言，不同数据库有不同实现，MySQL是LIMIT</li><li>如果查询的是第一页数据，起始索引可以省略，直接简写 LIMIT 10</li></ul><h4 id="dql执行顺序"><a class="markdownIt-Anchor" href="#dql执行顺序"></a> DQL执行顺序</h4><p>FROM -&gt; WHERE -&gt; GROUP BY -&gt; SELECT -&gt; ORDER BY -&gt; LIMIT</p><h3 id="dcl"><a class="markdownIt-Anchor" href="#dcl"></a> DCL</h3><h4 id="管理用户"><a class="markdownIt-Anchor" href="#管理用户"></a> 管理用户</h4><p>查询用户：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">USE mysql;</span><br><span class="line">SELECT * FROM user;</span><br></pre></td></tr></table></figure><p>创建用户:<br /><code>CREATE USER '用户名'@'主机名' IDENTIFIED BY '密码';</code></p><p>修改用户密码：<br /><code>ALTER USER '用户名'@'主机名' IDENTIFIED WITH mysql_native_password BY '新密码';</code></p><p>删除用户：<br /><code>DROP USER '用户名'@'主机名';</code></p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-- 创建用户test，只能在当前主机localhost访问</span><br><span class="line">create user &#x27;test&#x27;@&#x27;localhost&#x27; identified by &#x27;123456&#x27;;</span><br><span class="line">-- 创建用户test，能在任意主机访问</span><br><span class="line">create user &#x27;test&#x27;@&#x27;%&#x27; identified by &#x27;123456&#x27;;</span><br><span class="line">create user &#x27;test&#x27; identified by &#x27;123456&#x27;;</span><br><span class="line">-- 修改密码</span><br><span class="line">alter user &#x27;test&#x27;@&#x27;localhost&#x27; identified with mysql_native_password by &#x27;1234&#x27;;</span><br><span class="line">-- 删除用户</span><br><span class="line">drop user &#x27;test&#x27;@&#x27;localhost&#x27;;</span><br></pre></td></tr></table></figure><h5 id="注意事项-6"><a class="markdownIt-Anchor" href="#注意事项-6"></a> 注意事项</h5><ul><li>主机名可以使用 % 通配</li></ul><h4 id="权限控制"><a class="markdownIt-Anchor" href="#权限控制"></a> 权限控制</h4><p>常用权限：</p><table><thead><tr><th>权限</th><th>说明</th></tr></thead><tbody><tr><td>ALL, ALL PRIVILEGES</td><td>所有权限</td></tr><tr><td>SELECT</td><td>查询数据</td></tr><tr><td>INSERT</td><td>插入数据</td></tr><tr><td>UPDATE</td><td>修改数据</td></tr><tr><td>DELETE</td><td>删除数据</td></tr><tr><td>ALTER</td><td>修改表</td></tr><tr><td>DROP</td><td>删除数据库/表/视图</td></tr><tr><td>CREATE</td><td>创建数据库/表</td></tr></tbody></table><p>更多权限请看<a href="#%E6%9D%83%E9%99%90%E4%B8%80%E8%A7%88%E8%A1%A8" title="权限一览表">权限一览表</a></p><p>查询权限：<br /><code>SHOW GRANTS FOR '用户名'@'主机名';</code></p><p>授予权限：<br /><code>GRANT 权限列表 ON 数据库名.表名 TO '用户名'@'主机名';</code></p><p>撤销权限：<br /><code>REVOKE 权限列表 ON 数据库名.表名 FROM '用户名'@'主机名';</code></p><h5 id="注意事项-7"><a class="markdownIt-Anchor" href="#注意事项-7"></a> 注意事项</h5><ul><li>多个权限用逗号分隔</li><li>授权时，数据库名和表名可以用 * 进行通配，代表所有</li></ul><h2 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> 函数</h2><ul><li>字符串函数</li><li>数值函数</li><li>日期函数</li><li>流程函数</li></ul><h3 id="字符串函数"><a class="markdownIt-Anchor" href="#字符串函数"></a> 字符串函数</h3><p>常用函数：</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CONCAT(s1, s2, …, sn)</td><td>字符串拼接，将s1, s2, …, sn拼接成一个字符串</td></tr><tr><td>LOWER(str)</td><td>将字符串全部转为小写</td></tr><tr><td>UPPER(str)</td><td>将字符串全部转为大写</td></tr><tr><td>LPAD(str, n, pad)</td><td>左填充，用字符串pad对str的左边进行填充，达到n个字符串长度</td></tr><tr><td>RPAD(str, n, pad)</td><td>右填充，用字符串pad对str的右边进行填充，达到n个字符串长度</td></tr><tr><td>TRIM(str)</td><td>去掉字符串头部和尾部的空格</td></tr><tr><td>SUBSTRING(str, start, len)</td><td>返回从字符串str从start位置起的len个长度的字符串</td></tr><tr><td>REPLACE(column, source, replace)</td><td>替换字符串</td></tr></tbody></table><p>使用示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-- 拼接</span><br><span class="line">SELECT CONCAT(&#x27;Hello&#x27;, &#x27;World&#x27;);</span><br><span class="line">-- 小写</span><br><span class="line">SELECT LOWER(&#x27;Hello&#x27;);</span><br><span class="line">-- 大写</span><br><span class="line">SELECT UPPER(&#x27;Hello&#x27;);</span><br><span class="line">-- 左填充</span><br><span class="line">SELECT LPAD(&#x27;01&#x27;, 5, &#x27;-&#x27;);</span><br><span class="line">-- 右填充</span><br><span class="line">SELECT RPAD(&#x27;01&#x27;, 5, &#x27;-&#x27;);</span><br><span class="line">-- 去除空格</span><br><span class="line">SELECT TRIM(&#x27; Hello World &#x27;);</span><br><span class="line">-- 切片（起始索引为1）</span><br><span class="line">SELECT SUBSTRING(&#x27;Hello World&#x27;, 1, 5);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="数值函数"><a class="markdownIt-Anchor" href="#数值函数"></a> 数值函数</h3><p>常见函数：</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CEIL(x)</td><td>向上取整</td></tr><tr><td>FLOOR(x)</td><td>向下取整</td></tr><tr><td>MOD(x, y)</td><td>返回x/y的模</td></tr><tr><td>RAND()</td><td>返回0~1内的随机数</td></tr><tr><td>ROUND(x, y)</td><td>求参数x的四舍五入值，保留y位小数</td></tr></tbody></table><h3 id="日期函数"><a class="markdownIt-Anchor" href="#日期函数"></a> 日期函数</h3><p>常用函数：</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CURDATE()</td><td>返回当前日期</td></tr><tr><td>CURTIME()</td><td>返回当前时间</td></tr><tr><td>NOW()</td><td>返回当前日期和时间</td></tr><tr><td>YEAR(date)</td><td>获取指定date的年份</td></tr><tr><td>MONTH(date)</td><td>获取指定date的月份</td></tr><tr><td>DAY(date)</td><td>获取指定date的日期</td></tr><tr><td>DATE_ADD(date, INTERVAL expr type)</td><td>返回一个日期/时间值加上一个时间间隔expr后的时间值</td></tr><tr><td>DATEDIFF(date1, date2)</td><td>返回起始时间date1和结束时间date2之间的天数</td></tr></tbody></table><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- DATE_ADD</span><br><span class="line">SELECT DATE_ADD(NOW(), INTERVAL 70 YEAR);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="流程函数"><a class="markdownIt-Anchor" href="#流程函数"></a> 流程函数</h3><p>常用函数：</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>IF(value, t, f)</td><td>如果value为true，则返回t，否则返回f</td></tr><tr><td>IFNULL(value1, value2)</td><td>如果value1不为空，返回value1，否则返回value2</td></tr><tr><td>CASE WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END</td><td>如果val1为true，返回res1，… 否则返回default默认值</td></tr><tr><td>CASE [ expr ] WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END</td><td>如果expr的值等于val1，返回res1，… 否则返回default默认值</td></tr></tbody></table><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">name,</span><br><span class="line">(case when age &gt; 30 then &#x27;中年&#x27; else &#x27;青年&#x27; end)</span><br><span class="line">from employee;</span><br><span class="line">select</span><br><span class="line">name,</span><br><span class="line">(case workaddress when &#x27;北京市&#x27; then &#x27;一线城市&#x27; when &#x27;上海市&#x27; then &#x27;一线城市&#x27; else &#x27;二线城市&#x27; end) as &#x27;工作地址&#x27;</span><br><span class="line">from employee;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="约束"><a class="markdownIt-Anchor" href="#约束"></a> 约束</h2><p>分类：</p><table><thead><tr><th>约束</th><th>描述</th><th>关键字</th></tr></thead><tbody><tr><td>非空约束</td><td>限制该字段的数据不能为null</td><td>NOT NULL</td></tr><tr><td>唯一约束</td><td>保证该字段的所有数据都是唯一、不重复的</td><td>UNIQUE</td></tr><tr><td>主键约束</td><td>主键是一行数据的唯一标识，要求非空且唯一</td><td>PRIMARY KEY</td></tr><tr><td>默认约束</td><td>保存数据时，如果未指定该字段的值，则采用默认值</td><td>DEFAULT</td></tr><tr><td>检查约束（8.0.1版本后）</td><td>保证字段值满足某一个条件</td><td>CHECK</td></tr><tr><td>外键约束</td><td>用来让两张图的数据之间建立连接，保证数据的一致性和完整性</td><td>FOREIGN KEY</td></tr></tbody></table><p>约束是作用于表中字段上的，可以再创建表/修改表的时候添加约束。</p><h3 id="常用约束"><a class="markdownIt-Anchor" href="#常用约束"></a> 常用约束</h3><table><thead><tr><th>约束条件</th><th>关键字</th></tr></thead><tbody><tr><td>主键</td><td>PRIMARY KEY</td></tr><tr><td>自动增长</td><td>AUTO_INCREMENT</td></tr><tr><td>不为空</td><td>NOT NULL</td></tr><tr><td>唯一</td><td>UNIQUE</td></tr><tr><td>逻辑条件</td><td>CHECK</td></tr><tr><td>默认值</td><td>DEFAULT</td></tr></tbody></table><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create table user(</span><br><span class="line">id int primary key auto_increment,</span><br><span class="line">name varchar(10) not null unique,</span><br><span class="line">age int check(age &gt; 0 and age &lt; 120),</span><br><span class="line">status char(1) default &#x27;1&#x27;,</span><br><span class="line">gender char(1)</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="外键约束"><a class="markdownIt-Anchor" href="#外键约束"></a> 外键约束</h3><p>添加外键：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">字段名 字段类型,</span><br><span class="line">...</span><br><span class="line">[CONSTRAINT] [外键名称] FOREIGN KEY(外键字段名) REFERENCES 主表(主表列名)</span><br><span class="line">);</span><br><span class="line">ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名) REFERENCES 主表(主表列名);</span><br><span class="line"></span><br><span class="line">-- 例子</span><br><span class="line">alter table emp add constraint fk_emp_dept_id foreign key(dept_id) references dept(id);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>删除外键：<br /><code>ALTER TABLE 表名 DROP FOREIGN KEY 外键名;</code></p><h4 id="删除更新行为"><a class="markdownIt-Anchor" href="#删除更新行为"></a> 删除/更新行为</h4><table><thead><tr><th>行为</th><th>说明</th></tr></thead><tbody><tr><td>NO ACTION</td><td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新（与RESTRICT一致）</td></tr><tr><td>RESTRICT</td><td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新（与NO ACTION一致）</td></tr><tr><td>CASCADE</td><td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则也删除/更新外键在子表中的记录</td></tr><tr><td>SET NULL</td><td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null（要求该外键允许为null）</td></tr><tr><td>SET DEFAULT</td><td>父表有变更时，子表将外键设为一个默认值（Innodb不支持）</td></tr></tbody></table><p>更改删除/更新行为：<br /><code>ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES 主表名(主表字段名) ON UPDATE 行为 ON DELETE 行为;</code></p><h2 id="多表查询"><a class="markdownIt-Anchor" href="#多表查询"></a> 多表查询</h2><h3 id="多表关系"><a class="markdownIt-Anchor" href="#多表关系"></a> 多表关系</h3><ul><li>一对多（多对一）</li><li>多对多</li><li>一对一</li></ul><h4 id="一对多"><a class="markdownIt-Anchor" href="#一对多"></a> 一对多</h4><p>案例：部门与员工<br />关系：一个部门对应多个员工，一个员工对应一个部门<br />实现：在多的一方建立外键，指向一的一方的主键</p><h4 id="多对多"><a class="markdownIt-Anchor" href="#多对多"></a> 多对多</h4><p>案例：学生与课程<br />关系：一个学生可以选多门课程，一门课程也可以供多个学生选修<br />实现：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键</p><h4 id="一对一"><a class="markdownIt-Anchor" href="#一对一"></a> 一对一</h4><p>案例：用户与用户详情<br />关系：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率<br />实现：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的（UNIQUE）</p><h3 id="查询"><a class="markdownIt-Anchor" href="#查询"></a> 查询</h3><p>合并查询（笛卡尔积，会展示所有组合结果）：<br /><code>select * from employee, dept;</code></p><blockquote><p>笛卡尔积：两个集合A集合和B集合的所有组合情况（在多表查询时，需要消除无效的笛卡尔积）</p></blockquote><p>消除无效笛卡尔积：<br /><code>select * from employee, dept where employee.dept = dept.id;</code></p><h3 id="内连接查询"><a class="markdownIt-Anchor" href="#内连接查询"></a> 内连接查询</h3><p>内连接查询的是两张表交集的部分</p><p>隐式内连接：<br /><code>SELECT 字段列表 FROM 表1, 表2 WHERE 条件 ...;</code></p><p>显式内连接：<br /><code>SELECT 字段列表 FROM 表1 [ INNER ] JOIN 表2 ON 连接条件 ...;</code></p><p>显式性能比隐式高</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 查询员工姓名，及关联的部门的名称</span><br><span class="line">-- 隐式</span><br><span class="line">select e.name, d.name from employee as e, dept as d where e.dept = d.id;</span><br><span class="line">-- 显式</span><br><span class="line">select e.name, d.name from employee as e inner join dept as d on e.dept = d.id;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="外连接查询"><a class="markdownIt-Anchor" href="#外连接查询"></a> 外连接查询</h3><p>左外连接：<br />查询左表所有数据，以及两张表交集部分数据<br /><code>SELECT 字段列表 FROM 表1 LEFT [ OUTER ] JOIN 表2 ON 条件 ...;</code><br />相当于查询表1的所有数据，包含表1和表2交集部分数据</p><p>右外连接：<br />查询右表所有数据，以及两张表交集部分数据<br /><code>SELECT 字段列表 FROM 表1 RIGHT [ OUTER ] JOIN 表2 ON 条件 ...;</code></p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 左</span><br><span class="line">select e.*, d.name from employee as e left outer join dept as d on e.dept = d.id;</span><br><span class="line">select d.name, e.* from dept d left outer join emp e on e.dept = d.id;  -- 这条语句与下面的语句效果一样</span><br><span class="line">-- 右</span><br><span class="line">select d.name, e.* from employee as e right outer join dept as d on e.dept = d.id;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>左连接可以查询到没有dept的employee，右连接可以查询到没有employee的dept</p><h3 id="自连接查询"><a class="markdownIt-Anchor" href="#自连接查询"></a> 自连接查询</h3><p>当前表与自身的连接查询，自连接必须使用表别名</p><p>语法：<br /><code>SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件 ...;</code></p><p>自连接查询，可以是内连接查询，也可以是外连接查询</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 查询员工及其所属领导的名字</span><br><span class="line">select a.name, b.name from employee a, employee b where a.manager = b.id;</span><br><span class="line">-- 没有领导的也查询出来</span><br><span class="line">select a.name, b.name from employee a left join employee b on a.manager = b.id;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="联合查询-union-union-all"><a class="markdownIt-Anchor" href="#联合查询-union-union-all"></a> 联合查询 union, union all</h3><p>把多次查询的结果合并，形成一个新的查询集</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表A ...</span><br><span class="line">UNION [ALL]</span><br><span class="line">SELECT 字段列表 FROM 表B ...</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="注意事项-8"><a class="markdownIt-Anchor" href="#注意事项-8"></a> 注意事项</h4><ul><li>UNION ALL 会有重复结果，UNION 不会</li><li>联合查询比使用or效率高，不会使索引失效</li></ul><h3 id="子查询"><a class="markdownIt-Anchor" href="#子查询"></a> 子查询</h3><p>SQL语句中嵌套SELECT语句，称谓嵌套查询，又称子查询。<br /><code>SELECT * FROM t1 WHERE column1 = ( SELECT column1 FROM t2);</code><br /><strong>子查询外部的语句可以是 INSERT / UPDATE / DELETE / SELECT 的任何一个</strong></p><p>根据子查询结果可以分为：</p><ul><li>标量子查询（子查询结果为单个值）</li><li>列子查询（子查询结果为一列）</li><li>行子查询（子查询结果为一行）</li><li>表子查询（子查询结果为多行多列）</li></ul><p>根据子查询位置可分为：</p><ul><li>WHERE 之后</li><li>FROM 之后</li><li>SELECT 之后</li></ul><h4 id="标量子查询"><a class="markdownIt-Anchor" href="#标量子查询"></a> 标量子查询</h4><p>子查询返回的结果是单个值（数字、字符串、日期等）。<br />常用操作符：- &lt; &gt; &gt; &gt;= &lt; &lt;=</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-- 查询销售部所有员工</span><br><span class="line">select id from dept where name = &#x27;销售部&#x27;;</span><br><span class="line">-- 根据销售部部门ID，查询员工信息</span><br><span class="line">select * from employee where dept = 4;</span><br><span class="line">-- 合并（子查询）</span><br><span class="line">select * from employee where dept = (select id from dept where name = &#x27;销售部&#x27;);</span><br><span class="line"></span><br><span class="line">-- 查询xxx入职之后的员工信息</span><br><span class="line">select * from employee where entrydate &gt; (select entrydate from employee where name = &#x27;xxx&#x27;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="列子查询"><a class="markdownIt-Anchor" href="#列子查询"></a> 列子查询</h4><p>返回的结果是一列（可以是多行）。</p><p>常用操作符：</p><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>IN</td><td>在指定的集合范围内，多选一</td></tr><tr><td>NOT IN</td><td>不在指定的集合范围内</td></tr><tr><td>ANY</td><td>子查询返回列表中，有任意一个满足即可</td></tr><tr><td>SOME</td><td>与ANY等同，使用SOME的地方都可以使用ANY</td></tr><tr><td>ALL</td><td>子查询返回列表的所有值都必须满足</td></tr></tbody></table><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- 查询销售部和市场部的所有员工信息</span><br><span class="line">select * from employee where dept in (select id from dept where name = &#x27;销售部&#x27; or name = &#x27;市场部&#x27;);</span><br><span class="line">-- 查询比财务部所有人工资都高的员工信息</span><br><span class="line">select * from employee where salary &gt; all(select salary from employee where dept = (select id from dept where name = &#x27;财务部&#x27;));</span><br><span class="line">-- 查询比研发部任意一人工资高的员工信息</span><br><span class="line">select * from employee where salary &gt; any (select salary from employee where dept = (select id from dept where name = &#x27;研发部&#x27;));</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="行子查询"><a class="markdownIt-Anchor" href="#行子查询"></a> 行子查询</h4><p>返回的结果是一行（可以是多列）。<br />常用操作符：=, &lt;, &gt;, IN, NOT IN</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 查询与xxx的薪资及直属领导相同的员工信息</span><br><span class="line">select * from employee where (salary, manager) = (12500, 1);</span><br><span class="line">select * from employee where (salary, manager) = (select salary, manager from employee where name = &#x27;xxx&#x27;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="表子查询"><a class="markdownIt-Anchor" href="#表子查询"></a> 表子查询</h4><p>返回的结果是多行多列<br />常用操作符：IN</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 查询与xxx1，xxx2的职位和薪资相同的员工</span><br><span class="line">select * from employee where (job, salary) in (select job, salary from employee where name = &#x27;xxx1&#x27; or name = &#x27;xxx2&#x27;);</span><br><span class="line">-- 查询入职日期是2006-01-01之后的员工，及其部门信息</span><br><span class="line">select e.*, d.* from (select * from employee where entrydate &gt; &#x27;2006-01-01&#x27;) as e left join dept as d on e.dept = d.id;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="事务"><a class="markdownIt-Anchor" href="#事务"></a> 事务</h2><p>事务是一组操作的集合，事务会把所有操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p><p>基本操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">-- 1. 查询张三账户余额</span><br><span class="line">select * from account where name = &#x27;张三&#x27;;</span><br><span class="line">-- 2. 将张三账户余额-1000</span><br><span class="line">update account set money = money - 1000 where name = &#x27;张三&#x27;;</span><br><span class="line">-- 此语句出错后张三钱减少但是李四钱没有增加</span><br><span class="line">模拟sql语句错误</span><br><span class="line">-- 3. 将李四账户余额+1000</span><br><span class="line">update account set money = money + 1000 where name = &#x27;李四&#x27;;</span><br><span class="line"></span><br><span class="line">-- 查看事务提交方式</span><br><span class="line">SELECT @@AUTOCOMMIT;</span><br><span class="line">-- 设置事务提交方式，1为自动提交，0为手动提交，该设置只对当前会话有效</span><br><span class="line">SET @@AUTOCOMMIT = 0;</span><br><span class="line">-- 提交事务</span><br><span class="line">COMMIT;</span><br><span class="line">-- 回滚事务</span><br><span class="line">ROLLBACK;</span><br><span class="line"></span><br><span class="line">-- 设置手动提交后上面代码改为：</span><br><span class="line">select * from account where name = &#x27;张三&#x27;;</span><br><span class="line">update account set money = money - 1000 where name = &#x27;张三&#x27;;</span><br><span class="line">update account set money = money + 1000 where name = &#x27;李四&#x27;;</span><br><span class="line">commit;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>操作方式二：</p><p>开启事务：<br /><code>START TRANSACTION 或 BEGIN TRANSACTION;</code><br />提交事务：<br /><code>COMMIT;</code><br />回滚事务：<br /><code>ROLLBACK;</code></p><p>操作实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">select * from account where name = &#x27;张三&#x27;;</span><br><span class="line">update account set money = money - 1000 where name = &#x27;张三&#x27;;</span><br><span class="line">update account set money = money + 1000 where name = &#x27;李四&#x27;;</span><br><span class="line">commit;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="四大特性acid"><a class="markdownIt-Anchor" href="#四大特性acid"></a> 四大特性ACID</h3><ul><li>原子性(Atomicity)：事务是不可分割的最小操作但愿，要么全部成功，要么全部失败</li><li>一致性(Consistency)：事务完成时，必须使所有数据都保持一致状态</li><li>隔离性(Isolation)：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行</li><li>持久性(Durability)：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的</li></ul><h3 id="并发事务"><a class="markdownIt-Anchor" href="#并发事务"></a> 并发事务</h3><table><thead><tr><th>问题</th><th>描述</th></tr></thead><tbody><tr><td>脏读</td><td>一个事务读到另一个事务还没提交的数据</td></tr><tr><td>不可重复读</td><td>一个事务先后读取同一条记录，但两次读取的数据不同</td></tr><tr><td>幻读</td><td>一个事务按照条件查询数据时，没有对应的数据行，但是再插入数据时，又发现这行数据已经存在</td></tr></tbody></table><blockquote><p>这三个问题的详细演示：<a href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=55cd">https://www.bilibili.com/video/BV1Kr4y1i7ru?p=55cd</a></p></blockquote><p>并发事务隔离级别：</p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>Read uncommitted</td><td>√</td><td>√</td><td>√</td></tr><tr><td>Read committed</td><td>×</td><td>√</td><td>√</td></tr><tr><td>Repeatable Read(默认)</td><td>×</td><td>×</td><td>√</td></tr><tr><td>Serializable</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><ul><li>√表示在当前隔离级别下该问题会出现</li><li>Serializable 性能最低；Read uncommitted 性能最高，数据安全性最差</li></ul><p>查看事务隔离级别：<br /><code>SELECT @@TRANSACTION_ISOLATION;</code><br />设置事务隔离级别：<br /><code>SET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL &#123;READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE &#125;;</code><br />SESSION 是会话级别，表示只针对当前会话有效，GLOBAL 表示对所有会话有效</p><h1 id="进阶篇"><a class="markdownIt-Anchor" href="#进阶篇"></a> 进阶篇</h1><h2 id="存储引擎"><a class="markdownIt-Anchor" href="#存储引擎"></a> 存储引擎</h2><p>MySQL体系结构：</p><p><img src="MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt="结构图" title="结构图" /><br /><img src="MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%B1%82%E7%BA%A7%E5%90%AB%E4%B9%89.png" alt="层级描述" title="层级描述" /></p><p>存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。存储引擎是基于表而不是基于库的，所以存储引擎也可以被称为表引擎。<br />默认存储引擎是InnoDB。</p><p>相关操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-- 查询建表语句</span><br><span class="line">show create table account;</span><br><span class="line">-- 建表时指定存储引擎</span><br><span class="line">CREATE TABLE 表名(</span><br><span class="line">...</span><br><span class="line">) ENGINE=INNODB;</span><br><span class="line">-- 查看当前数据库支持的存储引擎</span><br><span class="line">show engines;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="innodb"><a class="markdownIt-Anchor" href="#innodb"></a> InnoDB</h3><p>InnoDB 是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB 是默认的 MySQL 引擎。</p><p>特点：</p><ul><li>DML 操作遵循 ACID 模型，支持<strong>事务</strong></li><li><strong>行级锁</strong>，提高并发访问性能</li><li>支持<strong>外键</strong>约束，保证数据的完整性和正确性</li></ul><p>文件：</p><ul><li>xxx.ibd: xxx代表表名，InnoDB 引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm、sdi）、数据和索引。</li></ul><p>参数：innodb_file_per_table，决定多张表共享一个表空间还是每张表对应一个表空间</p><p>知识点：</p><p>查看 Mysql 变量：<br /><code>show variables like 'innodb_file_per_table';</code></p><p>从idb文件提取表结构数据：<br />（在cmd运行）<br /><code>ibd2sdi xxx.ibd</code></p><p>InnoDB 逻辑存储结构：<br /><img src="%E9%80%BB%E8%BE%91%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png" alt="InnoDB逻辑存储结构" title="InnoDB逻辑存储结构" /></p><h3 id="myisam"><a class="markdownIt-Anchor" href="#myisam"></a> MyISAM</h3><p>MyISAM 是 MySQL 早期的默认存储引擎。</p><p>特点：</p><ul><li>不支持事务，不支持外键</li><li>支持表锁，不支持行锁</li><li>访问速度快</li></ul><p>文件：</p><ul><li>xxx.sdi: 存储表结构信息</li><li>xxx.MYD: 存储数据</li><li>xxx.MYI: 存储索引</li></ul><h3 id="memory"><a class="markdownIt-Anchor" href="#memory"></a> Memory</h3><p>Memory 引擎的表数据是存储在内存中的，受硬件问题、断电问题的影响，只能将这些表作为临时表或缓存使用。</p><p>特点：</p><ul><li>存放在内存中，速度快</li><li>hash索引（默认）</li></ul><p>文件：</p><ul><li>xxx.sdi: 存储表结构信息</li></ul><h3 id="存储引擎特点"><a class="markdownIt-Anchor" href="#存储引擎特点"></a> 存储引擎特点</h3><table><thead><tr><th>特点</th><th>InnoDB</th><th>MyISAM</th><th>Memory</th></tr></thead><tbody><tr><td>存储限制</td><td>64TB</td><td>有</td><td>有</td></tr><tr><td>事务安全</td><td>支持</td><td>-</td><td>-</td></tr><tr><td>锁机制</td><td>行锁</td><td>表锁</td><td>表锁</td></tr><tr><td>B+tree索引</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>Hash索引</td><td>-</td><td>-</td><td>支持</td></tr><tr><td>全文索引</td><td>支持（5.6版本之后）</td><td>支持</td><td>-</td></tr><tr><td>空间使用</td><td>高</td><td>低</td><td>N/A</td></tr><tr><td>内存使用</td><td>高</td><td>低</td><td>中等</td></tr><tr><td>批量插入速度</td><td>低</td><td>高</td><td>高</td></tr><tr><td>支持外键</td><td>支持</td><td>-</td><td>-</td></tr></tbody></table><h3 id="存储引擎的选择"><a class="markdownIt-Anchor" href="#存储引擎的选择"></a> 存储引擎的选择</h3><p>在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。</p><ul><li>InnoDB: 如果应用对事物的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，则 InnoDB 是比较合适的选择</li><li>MyISAM: 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不高，那这个存储引擎是非常合适的。</li><li>Memory: 将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。Memory 的缺陷是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性</li></ul><p>电商中的足迹和评论适合使用 MyISAM 引擎，缓存适合使用 Memory 引擎。</p><h2 id="性能分析"><a class="markdownIt-Anchor" href="#性能分析"></a> 性能分析</h2><h3 id="查看执行频次"><a class="markdownIt-Anchor" href="#查看执行频次"></a> 查看执行频次</h3><p>查看当前数据库的 INSERT, UPDATE, DELETE, SELECT 访问频次：<br /><code>SHOW GLOBAL STATUS LIKE 'Com_______';</code> 或者 <code>SHOW SESSION STATUS LIKE 'Com_______';</code><br />例：<code>show global status like 'Com_______'</code></p><h3 id="慢查询日志"><a class="markdownIt-Anchor" href="#慢查询日志"></a> 慢查询日志</h3><p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。<br />MySQL的慢查询日志默认没有开启，需要在MySQL的配置文件（/etc/my.cnf）中配置如下信息：<br /># 开启慢查询日志开关<br />slow_query_log=1<br /># 设置慢查询日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志<br />long_query_time=2<br />更改后记得重启MySQL服务，日志文件位置：/var/lib/mysql/localhost-slow.log</p><p>查看慢查询日志开关状态：<br /><code>show variables like 'slow_query_log';</code></p><h3 id="profile"><a class="markdownIt-Anchor" href="#profile"></a> profile</h3><p>show profile 能在做SQL优化时帮我们了解时间都耗费在哪里。通过 have_profiling 参数，能看到当前 MySQL 是否支持 profile 操作：<br /><code>SELECT @@have_profiling;</code><br />profiling 默认关闭，可以通过set语句在session/global级别开启 profiling：<br /><code>SET profiling = 1;</code><br />查看所有语句的耗时：<br /><code>show profiles;</code><br />查看指定query_id的SQL语句各个阶段的耗时：<br /><code>show profile for query query_id;</code><br />查看指定query_id的SQL语句CPU的使用情况<br /><code>show profile cpu for query query_id;</code></p><h3 id="explain"><a class="markdownIt-Anchor" href="#explain"></a> explain</h3><p>EXPLAIN 或者 DESC 命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。<br />语法：<br /># 直接在select语句之前加上关键字 explain / desc<br />EXPLAIN SELECT 字段列表 FROM 表名 HWERE 条件;</p><p>EXPLAIN 各字段含义：</p><ul><li>id：select 查询的序列号，表示查询中执行 select 子句或者操作表的顺序（id相同，执行顺序从上到下；id不同，值越大越先执行）</li><li>select_type：表示 SELECT 的类型，常见取值有 SIMPLE（简单表，即不适用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION中的第二个或者后面的查询语句）、SUBQUERY（SELECT/WHERE之后包含了子查询）等</li><li>type：表示连接类型，性能由好到差的连接类型为 NULL、system、const、eq_ref、ref、range、index、all</li><li>possible_key：可能应用在这张表上的索引，一个或多个</li><li>Key：实际使用的索引，如果为 NULL，则没有使用索引</li><li>Key_len：表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好</li><li>rows：MySQL认为必须要执行的行数，在InnoDB引擎的表中，是一个估计值，可能并不总是准确的</li><li>filtered：表示返回结果的行数占需读取行数的百分比，filtered的值越大越好</li></ul><h2 id="索引"><a class="markdownIt-Anchor" href="#索引"></a> 索引</h2><p>索引是帮助 MySQL <strong>高效获取数据</strong>的<strong>数据结构（有序）</strong>。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查询算法，这种数据结构就是索引。</p><p>优缺点：</p><p>优点：</p><ul><li>提高数据检索效率，降低数据库的IO成本</li><li>通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗</li></ul><p>缺点：</p><ul><li>索引列也是要占用空间的</li><li>索引大大提高了查询效率，但降低了更新的速度，比如 INSERT、UPDATE、DELETE</li></ul><h3 id="索引结构"><a class="markdownIt-Anchor" href="#索引结构"></a> 索引结构</h3><table><thead><tr><th>索引结构</th><th>描述</th></tr></thead><tbody><tr><td>B+Tree</td><td>最常见的索引类型，大部分引擎都支持B+树索引</td></tr><tr><td>Hash</td><td>底层数据结构是用哈希表实现，只有精确匹配索引列的查询才有效，不支持范围查询</td></tr><tr><td>R-Tree(空间索引)</td><td>空间索引是 MyISAM 引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少</td></tr><tr><td>Full-Text(全文索引)</td><td>是一种通过建立倒排索引，快速匹配文档的方式，类似于 Lucene, Solr, ES</td></tr></tbody></table><table><thead><tr><th>索引</th><th>InnoDB</th><th>MyISAM</th><th>Memory</th></tr></thead><tbody><tr><td>B+Tree索引</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>Hash索引</td><td>不支持</td><td>不支持</td><td>支持</td></tr><tr><td>R-Tree索引</td><td>不支持</td><td>支持</td><td>不支持</td></tr><tr><td>Full-text</td><td>5.6版本后支持</td><td>支持</td><td>不支持</td></tr></tbody></table><h4 id="b-tree"><a class="markdownIt-Anchor" href="#b-tree"></a> B-Tree</h4><p><img src="%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="二叉树" title="二叉树" /></p><p>二叉树的缺点可以用红黑树来解决：<br /><img src="https://learning-logs-1253130399.cos.ap-guangzhou.myqcloud.com/editor/%E7%BA%A2%E9%BB%91%E6%A0%91_20220316163142686602.png" alt="红黑树" title="红黑树" /><br />红黑树也存在大数据量情况下，层级较深，检索速度慢的问题。</p><p>为了解决上述问题，可以使用 B-Tree 结构。<br />B-Tree (多路平衡查找树) 以一棵最大度数（max-degree，指一个节点的子节点个数）为5（5阶）的 b-tree 为例（每个节点最多存储4个key，5个指针）</p><p><img src="B-Tree%E7%BB%93%E6%9E%84.png" alt="B-Tree结构" title="B-Tree结构" /></p><blockquote><p>B-Tree 的数据插入过程动画参照：<a href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=68">https://www.bilibili.com/video/BV1Kr4y1i7ru?p=68</a><br />演示地址：<a href="https://www.cs.usfca.edu/~galles/visualization/BTree.html">https://www.cs.usfca.edu/~galles/visualization/BTree.html</a></p></blockquote><h4 id="btree"><a class="markdownIt-Anchor" href="#btree"></a> B+Tree</h4><p>结构图：</p><p><img src="B+Tree%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="B+Tree结构图" title="B+Tree结构图" /></p><blockquote><p>演示地址：<a href="https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html">https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html</a></p></blockquote><p>与 B-Tree 的区别：</p><ul><li>所有的数据都会出现在叶子节点</li><li>叶子节点形成一个单向链表</li></ul><p>MySQL 索引数据结构对经典的 B+Tree 进行了优化。在原 B+Tree 的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的 B+Tree，提高区间访问的性能。</p><p><img src="%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="MySQL B+Tree 结构图" title="MySQL B+Tree 结构图" /></p><h4 id="hash"><a class="markdownIt-Anchor" href="#hash"></a> Hash</h4><p>哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。<br />如果两个（或多个）键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可以通过链表来解决。</p><p><img src="https://learning-logs-1253130399.cos.ap-guangzhou.myqcloud.com/editor/Hash%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E5%9B%BE_20220317143226150679.png" alt="Hash索引原理图" title="Hash索引原理图" /></p><p>特点：</p><ul><li>Hash索引只能用于对等比较（=、in），不支持范围查询（betwwn、&gt;、&lt;、…）</li><li>无法利用索引完成排序操作</li><li>查询效率高，通常只需要一次检索就可以了，效率通常要高于 B+Tree 索引</li></ul><p>存储引擎支持：</p><ul><li>Memory</li><li>InnoDB: 具有自适应hash功能，hash索引是存储引擎根据 B+Tree 索引在指定条件下自动构建的</li></ul><h4 id="面试题"><a class="markdownIt-Anchor" href="#面试题"></a> 面试题</h4><ol><li>为什么 InnoDB 存储引擎选择使用 B+Tree 索引结构？</li></ol><ul><li>相对于二叉树，层级更少，搜索效率高</li><li>对于 B-Tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针也跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低</li><li>相对于 Hash 索引，B+Tree 支持范围匹配及排序操作</li></ul><h3 id="索引分类"><a class="markdownIt-Anchor" href="#索引分类"></a> 索引分类</h3><table><thead><tr><th>分类</th><th>含义</th><th>特点</th><th>关键字</th></tr></thead><tbody><tr><td>主键索引</td><td>针对于表中主键创建的索引</td><td>默认自动创建，只能有一个</td><td>PRIMARY</td></tr><tr><td>唯一索引</td><td>避免同一个表中某数据列中的值重复</td><td>可以有多个</td><td>UNIQUE</td></tr><tr><td>常规索引</td><td>快速定位特定数据</td><td>可以有多个</td><td></td></tr><tr><td>全文索引</td><td>全文索引查找的是文本中的关键词，而不是比较索引中的值</td><td>可以有多个</td><td>FULLTEXT</td></tr></tbody></table><p>在 InnoDB 存储引擎中，根据索引的存储形式，又可以分为以下两种：</p><table><thead><tr><th>分类</th><th>含义</th><th>特点</th></tr></thead><tbody><tr><td>聚集索引(Clustered Index)</td><td>将数据存储与索引放一块，索引结构的叶子节点保存了行数据</td><td>必须有，而且只有一个</td></tr><tr><td>二级索引(Secondary Index)</td><td>将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键</td><td>可以存在多个</td></tr></tbody></table><p>演示图：</p><p><img src="%E5%8E%9F%E7%90%86%E5%9B%BE.png" alt="大致原理" title="大致原理" /><br /><img src="https://learning-logs-1253130399.cos.ap-guangzhou.myqcloud.com/editor/%E6%BC%94%E7%A4%BA%E5%9B%BE_20220319215403721066.png" alt="演示图" title="演示图" /></p><p>聚集索引选取规则：</p><ul><li>如果存在主键，主键索引就是聚集索引</li><li>如果不存在主键，将使用第一个唯一(UNIQUE)索引作为聚集索引</li><li>如果表没有主键或没有合适的唯一索引，则 InnoDB 会自动生成一个 rowid 作为隐藏的聚集索引</li></ul><h4 id="思考题"><a class="markdownIt-Anchor" href="#思考题"></a> 思考题</h4><p>1. 以下 SQL 语句，哪个执行效率高？为什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select * from user where id = 10;</span><br><span class="line">select * from user where name = &#x27;Arm&#x27;;</span><br><span class="line">-- 备注：id为主键，name字段创建的有索引</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>答：第一条语句，因为第二条需要回表查询，相当于两个步骤。</p><p>2. InnoDB 主键索引的 B+Tree 高度为多少？</p><p>答：假设一行数据大小为1k，一页中可以存储16行这样的数据。InnoDB 的指针占用6个字节的空间，主键假设为bigint，占用字节数为8.<br />可得公式：<code>n * 8 + (n + 1) * 6 = 16 * 1024</code>，其中 8 表示 bigint 占用的字节数，n 表示当前节点存储的key的数量，(n + 1) 表示指针数量（比key多一个）。算出n约为1170。</p><p>如果树的高度为2，那么他能存储的数据量大概为：<code>1171 * 16 = 18736</code>；<br />如果树的高度为3，那么他能存储的数据量大概为：<code>1171 * 1171 * 16 = 21939856</code>。</p><p>另外，如果有成千上万的数据，那么就要考虑分表，涉及运维篇知识。</p><h3 id="语法"><a class="markdownIt-Anchor" href="#语法"></a> 语法</h3><p>创建索引：<br /><code>CREATE [ UNIQUE | FULLTEXT ] INDEX index_name ON table_name (index_col_name, ...);</code><br />如果不加 CREATE 后面不加索引类型参数，则创建的是常规索引</p><p>查看索引：<br /><code>SHOW INDEX FROM table_name;</code></p><p>删除索引：<br /><code>DROP INDEX index_name ON table_name;</code></p><p>案例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-- name字段为姓名字段，该字段的值可能会重复，为该字段创建索引</span><br><span class="line">create index idx_user_name on tb_user(name);</span><br><span class="line">-- phone手机号字段的值非空，且唯一，为该字段创建唯一索引</span><br><span class="line">create unique index idx_user_phone on tb_user (phone);</span><br><span class="line">-- 为profession, age, status创建联合索引</span><br><span class="line">create index idx_user_pro_age_stat on tb_user(profession, age, status);</span><br><span class="line">-- 为email建立合适的索引来提升查询效率</span><br><span class="line">create index idx_user_email on tb_user(email);</span><br><span class="line"></span><br><span class="line">-- 删除索引</span><br><span class="line">drop index idx_user_email on tb_user;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="使用规则"><a class="markdownIt-Anchor" href="#使用规则"></a> 使用规则</h3><h4 id="最左前缀法则"><a class="markdownIt-Anchor" href="#最左前缀法则"></a> 最左前缀法则</h4><p>如果索引关联了多列（联合索引），要遵守最左前缀法则，最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。<br />如果跳跃某一列，索引将部分失效（后面的字段索引失效）。</p><p>联合索引中，出现范围查询（&lt;, &gt;），范围查询右侧的列索引失效。可以用&gt;=或者&lt;=来规避索引失效问题。</p><h4 id="索引失效情况"><a class="markdownIt-Anchor" href="#索引失效情况"></a> 索引失效情况</h4><ol><li>在索引列上进行运算操作，索引将失效。如：<code>explain select * from tb_user where substring(phone, 10, 2) = '15';</code></li><li>字符串类型字段使用时，不加引号，索引将失效。如：<code>explain select * from tb_user where phone = 17799990015;</code>，此处phone的值没有加引号</li><li>模糊查询中，如果仅仅是尾部模糊匹配，索引不会是失效；如果是头部模糊匹配，索引失效。如：<code>explain select * from tb_user where profession like '%工程';</code>，前后都有 % 也会失效。</li><li>用 or 分割开的条件，如果 or 其中一个条件的列没有索引，那么涉及的索引都不会被用到。</li><li>如果 MySQL 评估使用索引比全表更慢，则不使用索引。</li></ol><h4 id="sql-提示"><a class="markdownIt-Anchor" href="#sql-提示"></a> SQL 提示</h4><p>是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。</p><p>例如，使用索引：<br /><code>explain select * from tb_user use index(idx_user_pro) where profession=&quot;软件工程&quot;;</code><br />不使用哪个索引：<br /><code>explain select * from tb_user ignore index(idx_user_pro) where profession=&quot;软件工程&quot;;</code><br />必须使用哪个索引：<br /><code>explain select * from tb_user force index(idx_user_pro) where profession=&quot;软件工程&quot;;</code></p><p>use 是建议，实际使用哪个索引 MySQL 还会自己权衡运行速度去更改，force就是无论如何都强制使用该索引。</p><h4 id="覆盖索引回表查询"><a class="markdownIt-Anchor" href="#覆盖索引回表查询"></a> 覆盖索引&amp;回表查询</h4><p>尽量使用覆盖索引（查询使用了索引，并且需要返回的列，在该索引中已经全部能找到），减少 select *。</p><p>explain 中 extra 字段含义：<br /><code>using index condition</code>：查找使用了索引，但是需要回表查询数据<br /><code>using where; using index;</code>：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询</p><p>如果在聚集索引中直接能找到对应的行，则直接返回行数据，只需要一次查询，哪怕是select *；如果在辅助索引中找聚集索引，如<code>select id, name from xxx where name='xxx';</code>，也只需要通过辅助索引(name)查找到对应的id，返回name和name索引对应的id即可，只需要一次查询；如果是通过辅助索引查找其他字段，则需要回表查询，如<code>select id, name, gender from xxx where name='xxx';</code></p><p>所以尽量不要用<code>select *</code>，容易出现回表查询，降低效率，除非有联合索引包含了所有字段</p><p>面试题：一张表，有四个字段（id, username, password, status），由于数据量大，需要对以下SQL语句进行优化，该如何进行才是最优方案：<br /><code>select id, username, password from tb_user where username='itcast';</code></p><p>解：给username和password字段建立联合索引，则不需要回表查询，直接覆盖索引</p><h4 id="前缀索引"><a class="markdownIt-Anchor" href="#前缀索引"></a> 前缀索引</h4><p>当字段类型为字符串（varchar, text等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO，影响查询效率，此时可以只降字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。</p><p>语法：<code>create index idx_xxxx on table_name(columnn(n));</code><br />前缀长度：可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。<br />求选择性公式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select count(distinct email) / count(*) from tb_user;</span><br><span class="line">select count(distinct substring(email, 1, 5)) / count(*) from tb_user;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>show index 里面的sub_part可以看到接取的长度</p><h4 id="单列索引联合索引"><a class="markdownIt-Anchor" href="#单列索引联合索引"></a> 单列索引&amp;联合索引</h4><p>单列索引：即一个索引只包含单个列<br />联合索引：即一个索引包含了多个列<br />在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。</p><p>单列索引情况：<br /><code>explain select id, phone, name from tb_user where phone = '17799990010' and name = '韩信';</code><br />这句只会用到phone索引字段</p><h5 id="注意事项-9"><a class="markdownIt-Anchor" href="#注意事项-9"></a> 注意事项</h5><ul><li>多条件联合查询时，MySQL优化器会评估哪个字段的索引效率更高，会选择该索引完成本次查询</li></ul><h3 id="设计原则"><a class="markdownIt-Anchor" href="#设计原则"></a> 设计原则</h3><ol><li>针对于数据量较大，且查询比较频繁的表建立索引</li><li>针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引</li><li>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高</li><li>如果是字符串类型的字段，字段长度较长，可以针对于字段的特点，建立前缀索引</li><li>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率</li><li>要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价就越大，会影响增删改的效率</li><li>如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询</li></ol><h2 id="sql-优化"><a class="markdownIt-Anchor" href="#sql-优化"></a> SQL 优化</h2><h3 id="插入数据"><a class="markdownIt-Anchor" href="#插入数据"></a> 插入数据</h3><p>普通插入：</p><ol><li>采用批量插入（一次插入的数据不建议超过1000条）</li><li>手动提交事务</li><li>主键顺序插入</li></ol><p>大批量插入：<br />如果一次性需要插入大批量数据，使用insert语句插入性能较低，此时可以使用MySQL数据库提供的load指令插入。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 客户端连接服务端时，加上参数 --local-infile（这一行在bash/cmd界面输入）</span><br><span class="line">mysql --local-infile -u root -p</span><br><span class="line"># 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关</span><br><span class="line">set global local_infile = 1;</span><br><span class="line">select @@local_infile;</span><br><span class="line"># 执行load指令将准备好的数据，加载到表结构中</span><br><span class="line">load data local infile &#x27;/root/sql1.log&#x27; into table &#x27;tb_user&#x27; fields terminated by &#x27;,&#x27; lines terminated by &#x27;\n&#x27;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="主键优化"><a class="markdownIt-Anchor" href="#主键优化"></a> 主键优化</h3><p>数据组织方式：在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表（Index organized table, IOT）</p><p>页分裂：页可以为空，也可以填充一般，也可以填充100%，每个页包含了2-N行数据（如果一行数据过大，会行溢出），根据主键排列。<br />页合并：当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记（flaged）为删除并且它的空间变得允许被其他记录声明使用。当页中删除的记录到达 MERGE_THRESHOLD（默认为页的50%），InnoDB会开始寻找最靠近的页（前后）看看是否可以将这两个页合并以优化空间使用。</p><p>MERGE_THRESHOLD：合并页的阈值，可以自己设置，在创建表或创建索引时指定</p><blockquote><p>文字说明不够清晰明了，具体可以看视频里的PPT演示过程：<a href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=90">https://www.bilibili.com/video/BV1Kr4y1i7ru?p=90</a></p></blockquote><p>主键设计原则：</p><ul><li>满足业务需求的情况下，尽量降低主键的长度</li><li>插入数据时，尽量选择顺序插入，选择使用 AUTO_INCREMENT 自增主键</li><li>尽量不要使用 UUID 做主键或者是其他的自然主键，如身份证号</li><li>业务操作时，避免对主键的修改</li></ul><h3 id="order-by优化"><a class="markdownIt-Anchor" href="#order-by优化"></a> order by优化</h3><ol><li>Using filesort：通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区 sort buffer 中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序</li><li>Using index：通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高</li></ol><p>如果order by字段全部使用升序排序或者降序排序，则都会走索引，但是如果一个字段升序排序，另一个字段降序排序，则不会走索引，explain的extra信息显示的是<code>Using index, Using filesort</code>，如果要优化掉Using filesort，则需要另外再创建一个索引，如：<code>create index idx_user_age_phone_ad on tb_user(age asc, phone desc);</code>，此时使用<code>select id, age, phone from tb_user order by age asc, phone desc;</code>会全部走索引</p><p>总结：</p><ul><li>根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则</li><li>尽量使用覆盖索引</li><li>多字段排序，一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC/DESC）</li><li>如果不可避免出现filesort，大数据量排序时，可以适当增大排序缓冲区大小 sort_buffer_size（默认256k）</li></ul><h3 id="group-by优化"><a class="markdownIt-Anchor" href="#group-by优化"></a> group by优化</h3><ul><li>在分组操作时，可以通过索引来提高效率</li><li>分组操作时，索引的使用也是满足最左前缀法则的</li></ul><p>如索引为<code>idx_user_pro_age_stat</code>，则句式可以是<code>select ... where profession order by age</code>，这样也符合最左前缀法则</p><h3 id="limit优化"><a class="markdownIt-Anchor" href="#limit优化"></a> limit优化</h3><p>常见的问题如<code>limit 2000000, 10</code>，此时需要 MySQL 排序前2000000条记录，但仅仅返回2000000 - 2000010的记录，其他记录丢弃，查询排序的代价非常大。<br />优化方案：一般分页查询时，通过创建覆盖索引能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-- 此语句耗时很长</span><br><span class="line">select * from tb_sku limit 9000000, 10;</span><br><span class="line">-- 通过覆盖索引加快速度，直接通过主键索引进行排序及查询</span><br><span class="line">select id from tb_sku order by id limit 9000000, 10;</span><br><span class="line">-- 下面的语句是错误的，因为 MySQL 不支持 in 里面使用 limit</span><br><span class="line">-- select * from tb_sku where id in (select id from tb_sku order by id limit 9000000, 10);</span><br><span class="line">-- 通过连表查询即可实现第一句的效果，并且能达到第二句的速度</span><br><span class="line">select * from tb_sku as s, (select id from tb_sku order by id limit 9000000, 10) as a where s.id = a.id;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="count优化"><a class="markdownIt-Anchor" href="#count优化"></a> count优化</h3><p>MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高（前提是不适用where）；<br />InnoDB 在执行 count(*) 时，需要把数据一行一行地从引擎里面读出来，然后累计计数。<br />优化方案：自己计数，如创建key-value表存储在内存或硬盘，或者是用redis</p><p>count的几种用法：</p><ul><li>如果count函数的参数（count里面写的那个字段）不是NULL（字段值不为NULL），累计值就加一，最后返回累计值</li><li>用法：count(*)、count(主键)、count(字段)、count(1)</li><li>count(主键)跟count(*)一样，因为主键不能为空；count(字段)只计算字段值不为NULL的行；count(1)引擎会为每行添加一个1，然后就count这个1，返回结果也跟count(*)一样；count(null)返回0</li></ul><p>各种用法的性能：</p><ul><li>count(主键)：InnoDB引擎会遍历整张表，把每行的主键id值都取出来，返回给服务层，服务层拿到主键后，直接按行进行累加（主键不可能为空）</li><li>count(字段)：没有not null约束的话，InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层判断是否为null，不为null，计数累加；有not null约束的话，InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加</li><li>count(1)：InnoDB 引擎遍历整张表，但不取值。服务层对于返回的每一层，放一个数字 1 进去，直接按行进行累加</li><li>count(*)：InnoDB 引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行进行累加</li></ul><p>按效率排序：count(字段) &lt; count(主键) &lt; count(1) &lt; count(*)，所以尽量使用 count(*)</p><h3 id="update优化避免行锁升级为表锁"><a class="markdownIt-Anchor" href="#update优化避免行锁升级为表锁"></a> update优化（避免行锁升级为表锁）</h3><p>InnoDB 的行锁是针对索引加的锁，不是针对记录加的锁，并且该索引不能失效，否则会从行锁升级为表锁。</p><p>如以下两条语句：<br /><code>update student set no = '123' where id = 1;</code>，这句由于id有主键索引，所以只会锁这一行；<br /><code>update student set no = '123' where name = 'test';</code>，这句由于name没有索引，所以会把整张表都锁住进行数据更新，解决方法是给name字段添加索引</p><h1 id="数据类型"><a class="markdownIt-Anchor" href="#数据类型"></a> 数据类型</h1><h2 id="整型"><a class="markdownIt-Anchor" href="#整型"></a> 整型</h2><table><thead><tr><th>类型名称</th><th>取值范围</th><th>大小</th></tr></thead><tbody><tr><td>TINYINT</td><td>-128〜127</td><td>1个字节</td></tr><tr><td>SMALLINT</td><td>-32768〜32767</td><td>2个宇节</td></tr><tr><td>MEDIUMINT</td><td>-8388608〜8388607</td><td>3个字节</td></tr><tr><td>INT (INTEGHR)</td><td>-2147483648〜2147483647</td><td>4个字节</td></tr><tr><td>BIGINT</td><td>-9223372036854775808〜9223372036854775807</td><td>8个字节</td></tr></tbody></table><p>无符号在数据类型后加 unsigned 关键字。</p><h2 id="浮点型"><a class="markdownIt-Anchor" href="#浮点型"></a> 浮点型</h2><table><thead><tr><th>类型名称</th><th>说明</th><th>存储需求</th></tr></thead><tbody><tr><td>FLOAT</td><td>单精度浮点数</td><td>4 个字节</td></tr><tr><td>DOUBLE</td><td>双精度浮点数</td><td>8 个字节</td></tr><tr><td>DECIMAL (M, D)，DEC</td><td>压缩的“严格”定点数</td><td>M+2 个字节</td></tr></tbody></table><h2 id="日期和时间"><a class="markdownIt-Anchor" href="#日期和时间"></a> 日期和时间</h2><table><thead><tr><th>类型名称</th><th>日期格式</th><th>日期范围</th><th>存储需求</th></tr></thead><tbody><tr><td>YEAR</td><td>YYYY</td><td>1901 ~ 2155</td><td>1 个字节</td></tr><tr><td>TIME</td><td>HH:MM:SS</td><td>-838:59:59 ~ 838:59:59</td><td>3 个字节</td></tr><tr><td>DATE</td><td>YYYY-MM-DD</td><td>1000-01-01 ~ 9999-12-3</td><td>3 个字节</td></tr><tr><td>DATETIME</td><td>YYYY-MM-DD HH:MM:SS</td><td>1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</td><td>8 个字节</td></tr><tr><td>TIMESTAMP</td><td>YYYY-MM-DD HH:MM:SS</td><td>1980-01-01 00:00:01 UTC ~ 2040-01-19 03:14:07 UTC</td><td>4 个字节</td></tr></tbody></table><h2 id="字符串"><a class="markdownIt-Anchor" href="#字符串"></a> 字符串</h2><table><thead><tr><th>类型名称</th><th>说明</th><th>存储需求</th></tr></thead><tbody><tr><td>CHAR(M)</td><td>固定长度非二进制字符串</td><td>M 字节，1&lt;=M&lt;=255</td></tr><tr><td>VARCHAR(M)</td><td>变长非二进制字符串</td><td>L+1字节，在此，L&lt; = M和 1&lt;=M&lt;=255</td></tr><tr><td>TINYTEXT</td><td>非常小的非二进制字符串</td><td>L+1字节，在此，L&lt;2^8</td></tr><tr><td>TEXT</td><td>小的非二进制字符串</td><td>L+2字节，在此，L&lt;2^16</td></tr><tr><td>MEDIUMTEXT</td><td>中等大小的非二进制字符串</td><td>L+3字节，在此，L&lt;2^24</td></tr><tr><td>LONGTEXT</td><td>大的非二进制字符串</td><td>L+4字节，在此，L&lt;2^32</td></tr><tr><td>ENUM</td><td>枚举类型，只能有一个枚举字符串值</td><td>1或2个字节，取决于枚举值的数目 (最大值为65535)</td></tr><tr><td>SET</td><td>一个设置，字符串对象可以有零个或 多个SET成员</td><td>1、2、3、4或8个字节，取决于集合 成员的数量（最多64个成员）</td></tr></tbody></table><h2 id="二进制类型"><a class="markdownIt-Anchor" href="#二进制类型"></a> 二进制类型</h2><table><thead><tr><th>类型名称</th><th>说明</th><th>存储需求</th></tr></thead><tbody><tr><td>BIT(M)</td><td>位字段类型</td><td>大约 (M+7)/8 字节</td></tr><tr><td>BINARY(M)</td><td>固定长度二进制字符串</td><td>M 字节</td></tr><tr><td>VARBINARY (M)</td><td>可变长度二进制字符串</td><td>M+1 字节</td></tr><tr><td>TINYBLOB (M)</td><td>非常小的BLOB</td><td>L+1 字节，在此，L&lt;2^8</td></tr><tr><td>BLOB (M)</td><td>小 BLOB</td><td>L+2 字节，在此，L&lt;2^16</td></tr><tr><td>MEDIUMBLOB (M)</td><td>中等大小的BLOB</td><td>L+3 字节，在此，L&lt;2^24</td></tr><tr><td>LONGBLOB (M)</td><td>非常大的BLOB</td><td>L+4 字节，在此，L&lt;2^32</td></tr></tbody></table><h1 id="权限一览表"><a class="markdownIt-Anchor" href="#权限一览表"></a> 权限一览表</h1><blockquote><p>具体权限的作用详见<a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html" title="官方文档">官方文档</a></p></blockquote><p>GRANT 和 REVOKE 允许的静态权限</p><table><thead><tr><th style="text-align:left">Privilege</th><th style="text-align:left">Grant Table Column</th><th style="text-align:left">Context</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_all"><code>ALL [PRIVILEGES]</code></a></td><td style="text-align:left">Synonym for “all privileges”</td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_alter"><code>ALTER</code></a></td><td style="text-align:left"><code>Alter_priv</code></td><td style="text-align:left">Tables</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_alter-routine"><code>ALTER ROUTINE</code></a></td><td style="text-align:left"><code>Alter_routine_priv</code></td><td style="text-align:left">Stored routines</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create"><code>CREATE</code></a></td><td style="text-align:left"><code>Create_priv</code></td><td style="text-align:left">Databases, tables, or indexes</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-role"><code>CREATE ROLE</code></a></td><td style="text-align:left"><code>Create_role_priv</code></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-routine"><code>CREATE ROUTINE</code></a></td><td style="text-align:left"><code>Create_routine_priv</code></td><td style="text-align:left">Stored routines</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-tablespace"><code>CREATE TABLESPACE</code></a></td><td style="text-align:left"><code>Create_tablespace_priv</code></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-temporary-tables"><code>CREATE TEMPORARY TABLES</code></a></td><td style="text-align:left"><code>Create_tmp_table_priv</code></td><td style="text-align:left">Tables</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-user"><code>CREATE USER</code></a></td><td style="text-align:left"><code>Create_user_priv</code></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-view"><code>CREATE VIEW</code></a></td><td style="text-align:left"><code>Create_view_priv</code></td><td style="text-align:left">Views</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_delete"><code>DELETE</code></a></td><td style="text-align:left"><code>Delete_priv</code></td><td style="text-align:left">Tables</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_drop"><code>DROP</code></a></td><td style="text-align:left"><code>Drop_priv</code></td><td style="text-align:left">Databases, tables, or views</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_drop-role"><code>DROP ROLE</code></a></td><td style="text-align:left"><code>Drop_role_priv</code></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_event"><code>EVENT</code></a></td><td style="text-align:left"><code>Event_priv</code></td><td style="text-align:left">Databases</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_execute"><code>EXECUTE</code></a></td><td style="text-align:left"><code>Execute_priv</code></td><td style="text-align:left">Stored routines</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_file"><code>FILE</code></a></td><td style="text-align:left"><code>File_priv</code></td><td style="text-align:left">File access on server host</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_grant-option"><code>GRANT OPTION</code></a></td><td style="text-align:left"><code>Grant_priv</code></td><td style="text-align:left">Databases, tables, or stored routines</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_index"><code>INDEX</code></a></td><td style="text-align:left"><code>Index_priv</code></td><td style="text-align:left">Tables</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_insert"><code>INSERT</code></a></td><td style="text-align:left"><code>Insert_priv</code></td><td style="text-align:left">Tables or columns</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_lock-tables"><code>LOCK TABLES</code></a></td><td style="text-align:left"><code>Lock_tables_priv</code></td><td style="text-align:left">Databases</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_process"><code>PROCESS</code></a></td><td style="text-align:left"><code>Process_priv</code></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_proxy"><code>PROXY</code></a></td><td style="text-align:left">See <code>proxies_priv</code> table</td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_references"><code>REFERENCES</code></a></td><td style="text-align:left"><code>References_priv</code></td><td style="text-align:left">Databases or tables</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_reload"><code>RELOAD</code></a></td><td style="text-align:left"><code>Reload_priv</code></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_replication-client"><code>REPLICATION CLIENT</code></a></td><td style="text-align:left"><code>Repl_client_priv</code></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_replication-slave"><code>REPLICATION SLAVE</code></a></td><td style="text-align:left"><code>Repl_slave_priv</code></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_select"><code>SELECT</code></a></td><td style="text-align:left"><code>Select_priv</code></td><td style="text-align:left">Tables or columns</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_show-databases"><code>SHOW DATABASES</code></a></td><td style="text-align:left"><code>Show_db_priv</code></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_show-view"><code>SHOW VIEW</code></a></td><td style="text-align:left"><code>Show_view_priv</code></td><td style="text-align:left">Views</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_shutdown"><code>SHUTDOWN</code></a></td><td style="text-align:left"><code>Shutdown_priv</code></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_super"><code>SUPER</code></a></td><td style="text-align:left"><code>Super_priv</code></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_trigger"><code>TRIGGER</code></a></td><td style="text-align:left"><code>Trigger_priv</code></td><td style="text-align:left">Tables</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_update"><code>UPDATE</code></a></td><td style="text-align:left"><code>Update_priv</code></td><td style="text-align:left">Tables or columns</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_usage"><code>USAGE</code></a></td><td style="text-align:left">Synonym for “no privileges”</td><td style="text-align:left">Server administration</td></tr></tbody></table><p>GRANT 和 REVOKE 允许的动态权限</p><table><thead><tr><th style="text-align:left">Privilege</th><th style="text-align:left">Context</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_application-password-admin"><code>APPLICATION_PASSWORD_ADMIN</code></a></td><td style="text-align:left">Dual password administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_audit-abort-exempt"><code>AUDIT_ABORT_EXEMPT</code></a></td><td style="text-align:left">Allow queries blocked by audit log filter</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_audit-admin"><code>AUDIT_ADMIN</code></a></td><td style="text-align:left">Audit log administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_authentication-policy-admin"><code>AUTHENTICATION_POLICY_ADMIN</code></a></td><td style="text-align:left">Authentication administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_backup-admin"><code>BACKUP_ADMIN</code></a></td><td style="text-align:left">Backup administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_binlog-admin"><code>BINLOG_ADMIN</code></a></td><td style="text-align:left">Backup and Replication administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_binlog-encryption-admin"><code>BINLOG_ENCRYPTION_ADMIN</code></a></td><td style="text-align:left">Backup and Replication administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_clone-admin"><code>CLONE_ADMIN</code></a></td><td style="text-align:left">Clone administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_connection-admin"><code>CONNECTION_ADMIN</code></a></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_encryption-key-admin"><code>ENCRYPTION_KEY_ADMIN</code></a></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_firewall-admin"><code>FIREWALL_ADMIN</code></a></td><td style="text-align:left">Firewall administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_firewall-exempt"><code>FIREWALL_EXEMPT</code></a></td><td style="text-align:left">Firewall administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_firewall-user"><code>FIREWALL_USER</code></a></td><td style="text-align:left">Firewall administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_flush-optimizer-costs"><code>FLUSH_OPTIMIZER_COSTS</code></a></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_flush-status"><code>FLUSH_STATUS</code></a></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_flush-tables"><code>FLUSH_TABLES</code></a></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_flush-user-resources"><code>FLUSH_USER_RESOURCES</code></a></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_group-replication-admin"><code>GROUP_REPLICATION_ADMIN</code></a></td><td style="text-align:left">Replication administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_group-replication-stream"><code>GROUP_REPLICATION_STREAM</code></a></td><td style="text-align:left">Replication administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_innodb-redo-log-archive"><code>INNODB_REDO_LOG_ARCHIVE</code></a></td><td style="text-align:left">Redo log archiving administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_ndb-stored-user"><code>NDB_STORED_USER</code></a></td><td style="text-align:left">NDB Cluster</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_passwordless-user-admin"><code>PASSWORDLESS_USER_ADMIN</code></a></td><td style="text-align:left">Authentication administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_persist-ro-variables-admin"><code>PERSIST_RO_VARIABLES_ADMIN</code></a></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_replication-applier"><code>REPLICATION_APPLIER</code></a></td><td style="text-align:left"><code>PRIVILEGE_CHECKS_USER</code> for a replication channel</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_replication-slave-admin"><code>REPLICATION_SLAVE_ADMIN</code></a></td><td style="text-align:left">Replication administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_resource-group-admin"><code>RESOURCE_GROUP_ADMIN</code></a></td><td style="text-align:left">Resource group administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_resource-group-user"><code>RESOURCE_GROUP_USER</code></a></td><td style="text-align:left">Resource group administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_role-admin"><code>ROLE_ADMIN</code></a></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_session-variables-admin"><code>SESSION_VARIABLES_ADMIN</code></a></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_set-user-id"><code>SET_USER_ID</code></a></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_show-routine"><code>SHOW_ROUTINE</code></a></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_system-user"><code>SYSTEM_USER</code></a></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_system-variables-admin"><code>SYSTEM_VARIABLES_ADMIN</code></a></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_table-encryption-admin"><code>TABLE_ENCRYPTION_ADMIN</code></a></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_version-token-admin"><code>VERSION_TOKEN_ADMIN</code></a></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_xa-recover-admin"><code>XA_RECOVER_ADMIN</code></a></td><td style="text-align:left">Server administration</td></tr></tbody></table><h1 id="图形化界面工具"><a class="markdownIt-Anchor" href="#图形化界面工具"></a> 图形化界面工具</h1><ul><li>Workbench(免费): <a href="http://dev.mysql.com/downloads/workbench/">http://dev.mysql.com/downloads/workbench/</a></li><li>navicat(收费，试用版30天): <a href="https://www.navicat.com/en/download/navicat-for-mysql">https://www.navicat.com/en/download/navicat-for-mysql</a></li><li>Sequel Pro(开源免费，仅支持Mac OS): <a href="http://www.sequelpro.com/">http://www.sequelpro.com/</a></li><li>HeidiSQL(免费): <a href="http://www.heidisql.com/">http://www.heidisql.com/</a></li><li>phpMyAdmin(免费): <a href="https://www.phpmyadmin.net/">https://www.phpmyadmin.net/</a></li><li>SQLyog: <a href="https://sqlyog.en.softonic.com/">https://sqlyog.en.softonic.com/</a></li></ul><h1 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h1><h1 id="小技巧"><a class="markdownIt-Anchor" href="#小技巧"></a> 小技巧</h1><ol><li>在SQL语句之后加上<code>\G</code>会将结果的表格形式转换成行文本形式</li><li>查看Mysql数据库占用空间：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT table_schema &quot;Database Name&quot;</span><br><span class="line">     , SUM(data_length + index_length) / (1024 * 1024) &quot;Database Size in MB&quot;</span><br><span class="line">FROM information_schema.TABLES</span><br><span class="line">GROUP BY table_schema;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="后续内容"><a class="markdownIt-Anchor" href="#后续内容"></a> 后续内容</h1><p>后续内容因为跟当前学习、工作计划有冲突，所以后续课程的学习计划会无限期推后。<br />目前的工作重点放在重做一个学习笔记网站，当然这是边做边学的，开发过程中遇到的难点和知识点我也会记录下来供大家学习。<br /><strong>在此感谢B站同样爱学习的同学 @守心-人 提供的后续课程笔记，大家有条件一定要去给个star，你的每一个star和点赞都是我们前进的动力</strong><br /><strong><a href="https://github.com/Buildings-Lei/mysql_note/blob/main/README.md">https://github.com/Buildings-Lei/mysql_note/blob/main/README.md</a></strong></p>]]></content>
      
      
      <categories>
          
          <category> 数据库笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023YNU迎新杯程序设计大赛の题解</title>
      <link href="/posts/52957.html"/>
      <url>/posts/52957.html</url>
      
        <content type="html"><![CDATA[<h1 id="awelcome-to-yunnan"><a class="markdownIt-Anchor" href="#awelcome-to-yunnan"></a> A：Welcome to Yunnan！</h1><p>【知识点】 数学、思维题</p><p>【idea】</p><p>假如 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 的倍数，直接每个碟子放1个即可；</p><p>否则，由于每个碟子至少放一个，我们先在每个碟子内放一个</p><p>然后找到比n大的第一个k的倍数，把相差的这么多个均分到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 个碟子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">if</span>(n % k == <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ll sum = (n + k - <span class="number">1</span>) / k * k; <span class="comment">//找到比n大的第一个k的倍数</span></span><br><span class="line">        ll r = sum - n;</span><br><span class="line">        cout &lt;&lt; (r+n<span class="number">-1</span>)/n + <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="bwelcome-come-to-ynu"><a class="markdownIt-Anchor" href="#bwelcome-come-to-ynu"></a> B：Welcome come to YNU！</h1><p>【知识点】递推</p><p>【idea】</p><p>ynuer出现的次数，可通过每一个r之前出现的<code>ynue</code>的个数累加求得；</p><p>同理，yune出现的次数…</p><p>其实本题也可以改为用一个数组来递推，但由于<code>ynuer</code>比较短，用五个变量即可达到目的；假如要求计数的字符串长度很长，也可以照样通过数组来递推。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pdd pair<span class="string">&lt;double, double&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span><span class="number">+7</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    ll y = <span class="number">0</span>; <span class="comment">//y出现的个数</span></span><br><span class="line">    ll yn = <span class="number">0</span>; <span class="comment">//yn出现的个数</span></span><br><span class="line">    ll ynu = <span class="number">0</span>; <span class="comment">//ynu出现的个数</span></span><br><span class="line">    ll ynue = <span class="number">0</span>; <span class="comment">//ynue出现的个数</span></span><br><span class="line">    ll res = <span class="number">0</span>; <span class="comment">//ynuer出现的个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> c : s) &#123;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">&#x27;y&#x27;</span>) y ++;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">&#x27;n&#x27;</span>) yn = (yn + y) % mod;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">&#x27;u&#x27;</span>) ynu = (ynu + yn) % mod;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">&#x27;e&#x27;</span>) ynue = (ynue + ynu) % mod;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">&#x27;r&#x27;</span>) res = (res + ynue) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="c云上的气球派对"><a class="markdownIt-Anchor" href="#c云上的气球派对"></a> C：云上的气球派对</h1><p>【知识点】桶思想</p><p>考察对一维数组的理解，与桶思想类似，典</p><p>【idea】</p><p>设立一个元素数组、一个地址数组</p><p>交换的时候两个数组的值都要改变。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pdd pair<span class="string">&lt;double, double&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, q;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n<span class="number">+5</span>)</span>, <span class="title">p</span><span class="params">(n<span class="number">+5</span>)</span></span>;</span><br><span class="line">    <span class="comment">//a[i]元素数组：代表第i个气球上的数字</span></span><br><span class="line">    <span class="comment">//p[i]地址数组：代表写有i的气球所在位置编号</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        a[i] = p[i] = i;</span><br><span class="line">    <span class="keyword">while</span>(q --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        <span class="type">int</span> p1 = p[x], p2; <span class="comment">//p1记录x的原位置，p2记录x将前往的位置</span></span><br><span class="line">        <span class="keyword">if</span>(p1 != n) p2 = p1<span class="number">+1</span>;</span><br><span class="line">        <span class="keyword">else</span> p2 = p1<span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">swap</span>(a[p1], a[p2]);</span><br><span class="line">        p[a[p1]] = p1;</span><br><span class="line">        p[a[p2]] = p2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="d穿越之我是最伟大的卡牌大师"><a class="markdownIt-Anchor" href="#d穿越之我是最伟大的卡牌大师"></a> D：穿越之我是最伟大的卡牌大师！</h1><p>【知识点】贪心算法</p><p>【idea】</p><p>本题改编自某一年ICPC亚洲区域赛（南京）的签到题</p><p>首先，要使p/q越大，q-1的次数越多越好。</p><p>我们先尽可能多的把0都当做-1使，如果走到后面发现前面q加的不够，再来矫正。</p><p>这里有个技巧，用一个tot变量来记录此前<code>0-&gt;-1</code>的数量，就可以用O(1)实现矫正。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pdd pair<span class="string">&lt;double, double&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n<span class="number">+5</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="type">int</span> p = <span class="number">1</span>, q = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] == <span class="number">1</span>) &#123;</span><br><span class="line">            p ++, q ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(q &gt; <span class="number">1</span>) &#123; <span class="comment">//q还大于1，就把0当-1</span></span><br><span class="line">                q --;</span><br><span class="line">                tot ++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p ++;</span><br><span class="line">                q ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a[i] == <span class="number">-1</span>) &#123;</span><br><span class="line">            q --;</span><br><span class="line">            <span class="keyword">if</span>(q == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(tot &gt; <span class="number">0</span>) &#123; <span class="comment">//纠正一个0</span></span><br><span class="line">                    q += <span class="number">2</span>;</span><br><span class="line">                    p ++;</span><br><span class="line">                    tot --;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> g = __gcd(p, q);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, p/g, q/g);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    t = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="e穿越之我要玩魔兽争霸"><a class="markdownIt-Anchor" href="#e穿越之我要玩魔兽争霸"></a> E：穿越之我要玩魔兽争霸！</h1><p>【知识点】思维题</p><p>【idea】</p><p>首先，数据摆在那里了，这么大的数据，就不用考虑暴力模拟了。</p><p>这道题的过程虽然看着复杂，但是我们以宏观的视角去看这个问题，其实就没那么复杂。</p><p>需要重点关注的性质：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>+</mo><mi>y</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">x+y≤n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span></p><p>我们可以分两类情况讨论：</p><p>① <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>≤</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x≤y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 则一定每秒都可以召唤水元素，即可召唤m个；</p><p>② <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>&gt;</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x&gt;y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 时，一定不会超过魔法值上限，所以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span>秒的总魔法值为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>+</mo><mo stretchy="false">(</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>∗</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">n+(m-1)*y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>（因为最后一秒回复的魔法值是在召唤后所以用不到，故<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">m-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>），召唤一个水元素消耗<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>点魔法，故召唤水元素为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">min</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span></span></span></span> {<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo separator="true">,</mo><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mo stretchy="false">(</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>∗</mo><mi>y</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">m, (n+(m-1)*y)/x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathnormal">x</span></span></span></span>}。(之所以要取min，是因为当n很大时，得出的值可能大于m)</p><p>综合可得，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>n</mi><mi>s</mi><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>m</mi><mo separator="true">,</mo><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mo stretchy="false">(</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>∗</mo><mi>y</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">ans=min(m,(n+(m-1)*y)/x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">n</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pdd pair<span class="string">&lt;double, double&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n, m, x, y;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">min</span>(m, ((m<span class="number">-1</span>)*y+n)/x) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Fun Fact：出这题的时候出题人不再善良@_@没有让暴力做法过。</p><p>我们知道普通cpu在1s时限内可以做<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span>次运算，但一般做算法题的时候我们都需要把程序的最大操作数控制在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>8</mn></msup></mrow><annotation encoding="application/x-tex">10^8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span>以内，甚至有些题是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>7</mn></msup></mrow><annotation encoding="application/x-tex">10^7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span></span></span></span></span></span></span></span>以内。</p><p>这是因为：一方面，一个算法都是会有常数的，在实际运行过程中，算法的常数会使实际操作数增大一个或多个数量级；另一方面测评机运行和本地运行不太一样，申请地址空间、调用编译好的文件啊都是需要费时的。所以说上限不是1e9。</p><p>但是验题的时候，octal发现O(1e9)的数据在C++20开O2优化的情况下竟然可以只用700ms，所以之后就更改了时限。</p></blockquote><h1 id="f云山探险记"><a class="markdownIt-Anchor" href="#f云山探险记"></a> F：云山探险记</h1><p>【知识点】背包  / dp+二分</p><p>【idea】</p><p>两种做法：一种是当做前缀背包的板子题来做；一种是做一个思维的转化，转为一道<code>二分答案</code>来写</p><p>第一种做法有点超纲，算是铜牌算法了，目前不要求掌握。这里提供第二种解法。</p><p>其实很简单，假如一个物品是 “必要” 的，那么所有勇气值比它大的物品也一定是必要的。</p><p><strong>证明</strong> ：若 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span> 是必要的，则存在集合 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> 使得 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> 去掉 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span> 就 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">&lt;K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span>，加上 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span> 就<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≥</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">≥K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span>。那么对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> 中的任意一个大于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span> 的数，显然也一定是必要的。对于集合外任意一个大于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span> 的数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> ，也一定有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>−</mo><mi>x</mi><mo>+</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">S-x+y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 满足条件。</p><p>所以，我们二分查找这个边界即可。</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>h</mi><mi>e</mi><mi>c</mi><mi>k</mi></mrow><annotation encoding="application/x-tex">check</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 函数需要用到 DP，这个过程其实就等价于货币面值那个模型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n<span class="number">+5</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>()<span class="number">+1</span>, a.<span class="built_in">begin</span>()<span class="number">+1</span>+n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> check = [&amp;](<span class="type">int</span> x) &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; <span class="built_in">dp</span>(k<span class="number">+5</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        <span class="keyword">if</span>(i != x) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=k; j&gt;=a[i]; j--)</span><br><span class="line">                dp[j] |= dp[j-a[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="built_in">max</span>(k-a[x], <span class="number">0</span>); i&lt;=k<span class="number">-1</span>; i++)</span><br><span class="line">        <span class="keyword">if</span>(dp[i]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>, r = n<span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l+r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid<span class="number">+1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; n-l<span class="number">+1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="g黑白手"><a class="markdownIt-Anchor" href="#g黑白手"></a> G：黑白手</h1><p>【知识点】博弈论、思维题</p><p>【idea】</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>×</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">n × n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 的棋盘是中心对称的，所以后手的最优策略就是模仿先手；而先手的最优策略是尽可能多地走过棋盘的格子。</p><p>在双方的相互施法下，最终一定是能将棋盘的每个格子都走过。</p><p>那么，棋盘的格子总数为奇数，就是先手获胜；反之，则后手胜。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span>(n % <span class="number">2</span>) <span class="built_in">puts</span>(<span class="string">&quot;J&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;L&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="h幸福在哪里"><a class="markdownIt-Anchor" href="#h幸福在哪里"></a> H：幸福在哪里</h1><p>【知识点】暴力模拟 / 数学</p><p>作为签到题，本题数据范围很小，没有卡暴力做法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> n,k;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    string str=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            str+=<span class="string">&#x27;A&#x27;</span>+i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;str[k<span class="number">-1</span>]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>当然，除了暴力模拟，也可以直接得到答案</strong></p><p>（赛场上遇到这种范围的题，建议暴力做，肯定不会出错）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pdd pair<span class="string">&lt;double, double&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    cout &lt;&lt; (<span class="type">char</span>)((k+n<span class="number">-1</span>)/n + <span class="string">&#x27;A&#x27;</span> - <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="i幸福终将降临在我们头上"><a class="markdownIt-Anchor" href="#i幸福终将降临在我们头上"></a> I：幸福终将降临在我们头上</h1><p>【知识点】前缀数组+双指针算法 / 线段树 + 二分</p><p>【idea】</p><p>先想清楚一个结论：在一个序列中，假如要交换两数的位置，且只允许用类似冒泡排序交换方式，最少交换次数为两数之间的距离。</p><p>举例来说，我要交换 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">a[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">a[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> ，最少需要 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>i</mi><mo>−</mo><mi>j</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|i-j|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mord">∣</span></span></span></span> 次相邻交换。</p><p>接下来，我们再来想这道题要怎么做。</p><p>①第一步，先建立数学模型</p><p>我想让交换之后严格大于交换之前，是不是只要在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[k+1, n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">]</span></span></span></span> 之中找一个数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span> ，再在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mi>k</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1, k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span></span></span></span> 中找一个数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> ，满足 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>&gt;</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x &gt; y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>，然后交换两数即可。</p><p><strong>那么问题可以转化为，找一个区间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>L</mi><mo separator="true">,</mo><mi>R</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[L, R]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">L</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mclose">]</span></span></span></span>，使得区间包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>，并且 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>R</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[k+1,R]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mclose">]</span></span></span></span> 中 存在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span> , <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>L</mi><mo separator="true">,</mo><mi>k</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[L, k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">L</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span></span></span></span> 中存在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>，满足 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>&gt;</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x &gt; y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>。求对于所有满足条件的区间，区间长度的最小值。</strong></p><p>这种模型，一看就应该想到<strong>经典二分</strong>，可以二分区间长度然后 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>h</mi><mi>e</mi><mi>c</mi><mi>k</mi></mrow><annotation encoding="application/x-tex">check</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 一下，关于如何找 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x, y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> ，可以考虑使用线段树。</p><p>当然，对于这道题来说，二分还是属于暴力的做法，但不失为一个好方法。</p><p>接下来介绍另一种转化，运用了前缀数组的思想。</p><p>因为这道题重要的是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 之前和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 之后的大小关系，但并不是所有的数都是重要的。在k前只有大数重要，在k后只有小数重要。</p><p>我们可以用前缀最值（后缀最值）来维护这些数。</p><p>我们用前缀最值（后缀最值）可以把目光集中在对两边数组的大小关系起决定性变化的几个数（也就是我们维护的后缀min前缀max）而忽视掉不大不小的那些无关紧要的数。</p><p>然后就是双指针算法的应用了。</p><p>我们要求最小值嘛，外循环来移左边界，不断地去缩小区间长度。</p><p>为了更好地理解双指针的过程，我们需要明白一个这个前缀数组（后缀数组）的特性：</p><p>k前面是单调递增的，k后面也是单调递增的。</p><blockquote><p>O(n)</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pdd pair<span class="string">&lt;double, double&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n<span class="number">+5</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=k<span class="number">-1</span>; i&gt;=<span class="number">1</span>; i--)</span><br><span class="line">        a[i] = <span class="built_in">min</span>(a[i<span class="number">+1</span>], a[i]); <span class="comment">//前面找一个小的</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=k<span class="number">+2</span>; i&lt;=n; i++)</span><br><span class="line">        a[i] = <span class="built_in">max</span>(a[i<span class="number">-1</span>], a[i]); <span class="comment">//后面找一个大的</span></span><br><span class="line">    <span class="type">int</span> res = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>, j=k<span class="number">+1</span>; i&lt;=k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j &lt;= n &amp;&amp; a[j] &lt;= a[i])</span><br><span class="line">            j ++;</span><br><span class="line">        <span class="keyword">if</span>(j &lt;= n)</span><br><span class="line">            res = <span class="built_in">min</span>(res, j - i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(res &lt; <span class="number">1e9</span>) cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Lihg的本意是想考上面这个方法，但我验题的时候发现搓一个线段树也能过。</p><p>想着这道题能想到第一步转化，并且用线段树来实现也算很不错了，所以没有也并没有让出题人加强数据。</p><p>不过线段树方法属于暴力做法，时间复杂度还是很危险的，一不小心就会超时。</p><blockquote><p>O(nlogn*logn)</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pdd pair<span class="string">&lt;double, double&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">4e5</span><span class="number">+5</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> maxv;</span><br><span class="line">    <span class="type">int</span> minv;</span><br><span class="line">&#125; tr[N * <span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[id].maxv = <span class="built_in">max</span>(tr[id*<span class="number">2</span>].maxv, tr[id*<span class="number">2</span><span class="number">+1</span>].maxv);</span><br><span class="line">    tr[id].minv = <span class="built_in">min</span>(tr[id*<span class="number">2</span>].minv, tr[id*<span class="number">2</span><span class="number">+1</span>].minv);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> l ,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) </span><br><span class="line">        tr[id].maxv = tr[id].minv = a[l];</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> mid = l+r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(id * <span class="number">2</span>, l, mid);</span><br><span class="line">        <span class="built_in">build</span>(id * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="built_in">update</span>(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查询的区间为ql和qr max</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query1</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> ql, <span class="type">int</span> qr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == ql &amp;&amp; r == qr) <span class="keyword">return</span> tr[id].maxv;</span><br><span class="line">    <span class="type">int</span> mid = l+r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(qr &lt;= mid) <span class="keyword">return</span> <span class="built_in">query1</span>(id*<span class="number">2</span>, l, mid, ql, qr);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(ql &gt; mid) <span class="keyword">return</span> <span class="built_in">query1</span>(id*<span class="number">2</span><span class="number">+1</span>, mid<span class="number">+1</span>, r, ql, qr);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">query1</span>(id*<span class="number">2</span>, l, mid, ql, mid),</span><br><span class="line">    <span class="built_in">query1</span>(id*<span class="number">2</span><span class="number">+1</span>, mid<span class="number">+1</span>, r, mid<span class="number">+1</span>, qr));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查询的区间为ql和qr min</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query2</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> ql, <span class="type">int</span> qr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == ql &amp;&amp; r == qr) <span class="keyword">return</span> tr[id].minv;</span><br><span class="line">    <span class="type">int</span> mid = l+r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(qr &lt;= mid) <span class="keyword">return</span> <span class="built_in">query2</span>(id*<span class="number">2</span>, l, mid, ql, qr);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(ql &gt; mid) <span class="keyword">return</span> <span class="built_in">query2</span>(id*<span class="number">2</span><span class="number">+1</span>, mid<span class="number">+1</span>, r, ql, qr);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">min</span>(<span class="built_in">query2</span>(id*<span class="number">2</span>, l, mid, ql, mid),</span><br><span class="line">    <span class="built_in">query2</span>(id*<span class="number">2</span><span class="number">+1</span>, mid<span class="number">+1</span>, r, mid<span class="number">+1</span>, qr));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>&gt; hp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        hp.<span class="built_in">push</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; b, c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=k; i++) &#123;</span><br><span class="line">        b.<span class="built_in">insert</span>(a[i]);</span><br><span class="line">        c.<span class="built_in">insert</span>(hp.<span class="built_in">top</span>());</span><br><span class="line">        hp.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(b == c) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> check = [&amp;](<span class="type">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=k<span class="number">+1</span>; i&lt;=k+x; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> R = <span class="built_in">min</span>(n, i);</span><br><span class="line">            <span class="type">int</span> L = <span class="built_in">max</span>(<span class="number">1</span>, i-x);</span><br><span class="line">            <span class="type">int</span> minv = <span class="built_in">query2</span>(<span class="number">1</span>, <span class="number">1</span>, n, L, k);</span><br><span class="line">            <span class="type">int</span> maxv = <span class="built_in">query1</span>(<span class="number">1</span>, <span class="number">1</span>, n, k<span class="number">+1</span>, R);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(maxv &gt; minv) </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>, r = n;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> mid = l+r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; l &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 比赛题解 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YNUCPC-2024 官方题解</title>
      <link href="/posts/49243.html"/>
      <url>/posts/49243.html</url>
      
        <content type="html"><![CDATA[<h1 id="总览"><a class="markdownIt-Anchor" href="#总览"></a> 总览</h1><p><strong>出题人：<a href="https://www.luogu.com.cn/user/313822">Octal</a>、<a href="https://www.luogu.com.cn/user/769414">Lihg</a></strong><br /><strong>友情客串：Catherine、Catgok、小帅、GPT、派蒙</strong><br /><s>特别鸣谢：GPT同学对题面构造工作提供的支持！</s></p><hr /><p><strong>感谢所有参与内测的ICPC集训队队员：<br />① Ai,give me a name全队（Catgok、Nocoldinsummer、fexla）<br />② Ulterior Motive全队（KrowFeather、False0099、Leexxxx）<br />③ 特别鸣谢，远在USA的 <a href="https://www.luogu.com.cn/user/27470">Felix</a> 队长（ICPC集训队第一任队长）对验题工作的大力支持！</strong></p><hr /><p>本次校赛大部分题目（所有难题）的idea都来自我的队友<code>Lihg</code>，我的工作还是挺轻松的，就帮忙出出数据和写写题面，所以写题解的任务就还是我自己来吧。</p><p><strong>本文为官方题解，也鼓励各位YNU的小伙伴们发布自己的题解ヾ(◍°∇°◍)ﾉﾞ</strong></p><p><em>赛前故事：</em><br />一听说要出校赛了，Lihg一下子扔给了我8个题的idea，让我随便选，<s>看样子是蓄谋已久了</s> 。<br />我一看，什么难题、中档题、防AK题都有了，<s>虽然出题人表示都很一眼（狗头）</s> 。<br /><s>由此，Octal也可以摆烂了</s><br />由此，本次校赛的难度就被拉高了…<br />所以，善良的Octal还是不能摆烂，删了几个更难的题，自己出了几个简单题。<br />最后还是要感谢Lihg，贡献了几道非常不错的题目。<br />而且，他出的这些题，数据都很难出，为Lihg哥哥点赞o(￣▽￣)ｄ。</p><hr /><p>赛前预估是三个简单题（1–2），四个中档题（3–4），两个ICPC正赛难度题（5）。（更难的题被octal删了）</p><p>赛后update：<br />前期榜严重歪了T_T，01_Dreamer同学速度K了C题，导致大家都去写C（哭笑）。</p><p>其实从思维上说，B、H要更简单一些T_T</p><p>第二个偏的是E，其实很早的时候404liuyan（好像是研一学长）就拿下了一血，但可能是LaTeX把大家吓住了，导致很晚才有第二个人开E题。对我们算竞选手来说，类似题写多了，可能会觉得E比C要简单一些。</p><p>另一个一直没人开的题就是I题，I其实是一道纯纯的脑筋急转弯题，没涉及到算法。个人猜测：参赛集训队的退役队员们可能太久没打CF，对这些题手生了；而现役队员们看前排大佬都没写这题，也都不敢去试。还好最后知非同学力挽狂澜，让Lihg的题没白出。</p><p>总的来说还不错，每道题都有人AC了，有点ICPC的味道了，嘻嘻。</p><table><thead><tr><th></th><th>预估难度</th><th>知识点</th><th>FirstBlood</th><th>出题人</th></tr></thead><tbody><tr><td>A</td><td>1 ★</td><td>简单数学</td><td>01_Dreamer</td><td>Lihg</td></tr><tr><td>B</td><td>2 ★</td><td>数学、模拟（进制转换）</td><td>Frank000</td><td>octal</td></tr><tr><td>C</td><td>STD做法：3 ★<br> 其他做法：4 ★</td><td>STD做法：二分 + 前缀和 <br> 其他做法：① 线段树 + 二分<br> ② 离线查询 + 双指针 ③单调队列 + 二分</td><td>01_Dreamer</td><td>Lihg</td></tr><tr><td>D</td><td>4 – 5 ★</td><td>思维、树状数组 + 二分</td><td>01_Dreamer</td><td>Lihg</td></tr><tr><td>E</td><td>3 ★</td><td>思维、组合数学</td><td>404liuyan</td><td>octal</td></tr><tr><td>F</td><td>5 ★</td><td>拓扑排序 / 思维 + 并查集 / tarjan缩点</td><td>JALJAYO</td><td>Lihg</td></tr><tr><td>G</td><td>5 ★</td><td>树状数组 + DFN</td><td>ZZFreya</td><td>Lihg</td></tr><tr><td>H</td><td>1 – 2 ★</td><td>模拟、分类讨论</td><td>cqsbz_cxy</td><td>octal</td></tr><tr><td>I</td><td>4 ★</td><td>思维、模拟</td><td>Frank000</td><td>Lihg</td></tr></tbody></table><h1 id="a-幸运数字1"><a class="markdownIt-Anchor" href="#a-幸运数字1"></a> A 幸运数字（1）</h1><p>【数学】【签到】<br />首先，根据数学常识，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>−</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1-n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 中有多少个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 的倍数，用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mi>k</mi></mrow><annotation encoding="application/x-tex">n/k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> （整除）即可获得。<br />本题中我们要求 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>L</mi><mo separator="true">,</mo><mi>R</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[L, R]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">L</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mclose">]</span></span></span></span> 中有多少个3的倍数，只需要用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mi>R</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1, R]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mclose">]</span></span></span></span> 中3的倍数的个数 减去 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mi>L</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1, L-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 中3的倍数的个数，即可。<br />由于设定是签到题，就没有卡int，不需要开long long就能过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">    cout &lt;&lt; r/<span class="number">3</span> - (l<span class="number">-1</span>)/<span class="number">3</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="b-幸运数字2"><a class="markdownIt-Anchor" href="#b-幸运数字2"></a> B 幸运数字（2）</h1><p>【数学】【模拟】【签到】<br />每个数位只有0、3、6、9，四个数字，我们可以把这四个数字等价为0、1、2、3。<br />问题就转化为了在四进制下，第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 个自然数是什么。（大家联想一下，十进制其实就是每一个数位都只有 0-9 十种数字的数）<br />那么，写一个十进制转四进制的代码即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    n --; <span class="comment">// 自然数从0开始，第一个自然数是0</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; r;</span><br><span class="line">    <span class="comment">// 用vector来模拟栈</span></span><br><span class="line">    <span class="comment">// 用普通数组来模拟栈or直接用stack&lt;int&gt;都行</span></span><br><span class="line">    <span class="keyword">while</span>(n) &#123;</span><br><span class="line">        r.<span class="built_in">push_back</span>(n % <span class="number">4</span>);</span><br><span class="line">        n /= <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(r.<span class="built_in">size</span>() == <span class="number">0</span>) cout &lt;&lt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!r.<span class="built_in">empty</span>()) &#123; <span class="comment">// 倒序输出</span></span><br><span class="line">        <span class="comment">// vector用起来和栈是一样的</span></span><br><span class="line">        cout &lt;&lt; r.<span class="built_in">back</span>()*<span class="number">3</span>;</span><br><span class="line">        r.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t --)</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="c-应急食品"><a class="markdownIt-Anchor" href="#c-应急食品"></a> C 应急食品</h1><p>【二分】【前缀和】<br />先讲讲二分查找的做法吧，学过二分查找的小伙伴们应该都知道，在一个序列中二分查找一个数，需要满足一个前提：<strong>序列有序</strong>。（勿喷，狭义上可以这么理解）<br />但是，<strong>假如原数组有正有负，得到的前缀和数组是摆动的</strong>，不符合二分查找的前提条件。所以如果我们还想用二分查找的话，首要任务是让序列变得有序。<br />那如何让序列单调递增呢？</p><h2 id="做法一"><a class="markdownIt-Anchor" href="#做法一"></a> 做法一</h2><p><strong>一、一种做法是维护一个前缀和的前缀最大值即可</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pdd pair<span class="string">&lt;double, double&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pll pair<span class="string">&lt;ll, ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, q;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">pre</span><span class="params">(n<span class="number">+5</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        ll x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        pre[i] = pre[i<span class="number">-1</span>] + x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        pre[i] = <span class="built_in">max</span>(pre[i], pre[i<span class="number">-1</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(q --) &#123;</span><br><span class="line">        ll x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">1</span>, r = n;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = l+r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(pre[mid] &gt;= x) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pre[l] &gt;= x) cout &lt;&lt; l &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="做法二"><a class="markdownIt-Anchor" href="#做法二"></a> 做法二</h2><p><strong>二、第二种做法类似单调队列，我们维护一个单调的数组，只留下有用的数。</strong><br />这里附上Felix大佬的验题代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">vector&lt;ll&gt; pre_sum = &#123;<span class="number">0ll</span>&#125;;</span><br><span class="line">vector&lt;ll&gt; indices = &#123;<span class="number">0ll</span>&#125;;</span><br><span class="line"><span class="comment">// 下标是indices[i]的前缀和是pre_sum[i]</span></span><br><span class="line">ll a[<span class="number">100005</span>], n, q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += a[i];</span><br><span class="line">        <span class="keyword">if</span>(sum &gt; pre_sum.<span class="built_in">back</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            pre_sum.<span class="built_in">push_back</span>(sum);</span><br><span class="line">            indices.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        ll x; cin &gt;&gt; x;</span><br><span class="line">        <span class="keyword">if</span>(x &gt; pre_sum.<span class="built_in">back</span>())</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> pos = <span class="built_in">lower_bound</span>(pre_sum.<span class="built_in">begin</span>(), pre_sum.<span class="built_in">end</span>(), x) - pre_sum.<span class="built_in">begin</span>();</span><br><span class="line">            cout &lt;&lt; indices[pos] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="做法三"><a class="markdownIt-Anchor" href="#做法三"></a> 做法三</h2><p>三、<strong>当然，本题其实还有个离线做法</strong><br />把所有的询问存下来，从小到大排个序</p><p>因为在有解的情况下，更小的x对应的答案也一定是更小的</p><p>在这种单调一致性的条件下，就有点类似双指针的感觉，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> 一起往后移。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pdd pair<span class="string">&lt;double, double&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pll pair<span class="string">&lt;ll, ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, q;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">pre</span><span class="params">(n<span class="number">+1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        ll a;</span><br><span class="line">        cin &gt;&gt; a;</span><br><span class="line">        pre[i] = pre[i<span class="number">-1</span>] + a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;pll&gt; <span class="title">qs</span><span class="params">(q<span class="number">+1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=q; i++) &#123;</span><br><span class="line">        cin &gt;&gt; qs[i].first;</span><br><span class="line">        qs[i].second = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(qs.<span class="built_in">begin</span>()<span class="number">+1</span>, qs.<span class="built_in">end</span>(), [&amp;](pll a, pll b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.first &lt; b.first;</span><br><span class="line">    &#125;); <span class="comment">// 把询问从小到大排序</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(q<span class="number">+1</span>, <span class="number">-1</span>)</span></span>; <span class="comment">// 记录答案</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=q; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(j &lt;= n &amp;&amp; qs[i].first &gt; pre[j])</span><br><span class="line">            j ++;</span><br><span class="line">        <span class="keyword">if</span>(j &gt; n) <span class="keyword">break</span>;</span><br><span class="line">        res[qs[i].second] = j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=q; i++) &#123;</span><br><span class="line">        cout &lt;&lt; res[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">10</span>);</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>线段树 + 二分的做法就属于是“大炮打蚊子”了，不在此赘述。</p></blockquote><h1 id="d-逆序对传说"><a class="markdownIt-Anchor" href="#d-逆序对传说"></a> D 逆序对传说</h1><p>【树状数组+二分】【思维】<br />区间第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span> 大模板题（树状数组+二分模板题）<br />假如我们初始有一个序列，我们在序列末尾添加一个数，新增的逆序对数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>=</mo></mrow><annotation encoding="application/x-tex">=</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span></span></span></span> 此前比该数更大的数的个数</p><p>在回到这道题上来，我们从后往前对这个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span></span></span></span> 序列做一个差分。</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>−</mo><msub><mi>a</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">a_i-a_{i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span> 代表 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">p_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 所带来的逆序对数，即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 位置之前比 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">p_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的大的数的个数。</p><p>鉴于原序列是一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>−</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1-n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 的排列，每个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">p_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 都是固定元素集合中的元素。</p><p>我们把剩余未安排的元素看成一个集合，如果比 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">p_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 大的数有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 个，那么 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">p_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 就是这个第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">m+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 大的数。</p><p>问题就转化为了维护区间第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span> 大的模型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pdd pair<span class="string">&lt;double, double&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pll pair<span class="string">&lt;ll, ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fenwick</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    vector&lt;T&gt; tr;</span><br><span class="line">    <span class="built_in">Fenwick</span>(<span class="type">int</span> n) : <span class="built_in">n</span>(n), <span class="built_in">tr</span>(n + <span class="number">1</span>, <span class="number">0</span>)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, T c)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = x; i &lt;= n; i += <span class="built_in">lowbit</span>(i)) tr[i] += c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">sum</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        T res = <span class="built_in">T</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = x; i; i -= <span class="built_in">lowbit</span>(i)) res += tr[i];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">sum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(r) - <span class="built_in">sum</span>(l - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">a</span><span class="params">(n<span class="number">+1</span>)</span></span>;</span><br><span class="line">    a[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;=n; i++)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    <span class="function">Fenwick&lt;ll&gt; <span class="title">bit</span><span class="params">(n<span class="number">+1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        bit.<span class="built_in">add</span>(i, <span class="number">1</span>);</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n<span class="number">+1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n; i&gt;=<span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">1</span>, r=n;</span><br><span class="line">        ll k = a[i] - a[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (l+r<span class="number">+1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(bit.<span class="built_in">sum</span>(mid, n) &gt;= k) l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res[i] = l;</span><br><span class="line">        bit.<span class="built_in">add</span>(l, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        cout &lt;&lt; res[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t --)</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="e-集合运算"><a class="markdownIt-Anchor" href="#e-集合运算"></a> E 集合运算</h1><p>【组合数学】<br />题目要求所有元素个数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&gt;</mo><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">&gt;=2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> 的子集中第二大的元素之和，即求：S中的各个元素作为第二大元素出现在子集中的次数与该元素乘积之和。</p><p>我们可以先将所给集合元素从小到大排序，然后从左到右依次遍历  1 到 n-1 位置上的数（第n个元素不用遍历，因为它不可能是第二大），观察可发现：以该数作为子集中第二大元素，需要从该数右边的比它大的数中选一个元素(有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">n-i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 种选法)，然后该数左边的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 个元素都有选与不选两种情况(有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{i - 1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> 种情况)。</p><p>由乘法原理可知，遍历到第i个位置时，以该元素作为第二大元素在子集中出现的次数有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mi>i</mi><mo stretchy="false">)</mo><mo>×</mo><msup><mn>2</mn><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">(n - i) × 2 ^{i - 1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> 种情况，累加 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mi>i</mi><mo stretchy="false">)</mo><mo>×</mo><msup><mn>2</mn><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>×</mo><mi>a</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">(n - i) × 2 ^{i - 1} × a[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.907994em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 即可求得所需解。</p><p>这里需要注意，由于数据范围较大，会爆long long，需要进行取模处理。而取模需要注意的是，不能有中间量的溢出，所以要每运算一次就取模一次，具体操作详见代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pdd pair<span class="string">&lt;double, double&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pll pair<span class="string">&lt;ll, ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span><span class="number">+7</span>;</span><br><span class="line"><span class="function">ll <span class="title">qmi</span><span class="params">(ll a, ll b, ll mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ll res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(b) &#123;</span><br><span class="line"><span class="keyword">if</span>(b &amp; <span class="number">1</span>) res = res*a%mod;</span><br><span class="line">a = a*a%mod;</span><br><span class="line">b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">a</span><span class="params">(n<span class="number">+1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>()<span class="number">+1</span>, a.<span class="built_in">end</span>());</span><br><span class="line">    ll res = <span class="number">0</span>, k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>; i&lt;=n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        res = (res + a[i] * <span class="built_in">qmi</span>(<span class="number">2</span>, i<span class="number">-1</span>, mod) % mod * (n-i) % mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果不会快速幂，其实用一个变量迭代也能做，相当于每进行一轮循环就×2。</p></blockquote><h1 id="f-帮lihg关下灯"><a class="markdownIt-Anchor" href="#f-帮lihg关下灯"></a> F 帮Lihg关下灯</h1><h2 id="做法一-2"><a class="markdownIt-Anchor" href="#做法一-2"></a> 做法一</h2><p>【拓扑排序】【基环树】<br />对这道题进行数学建模：对于每一个关联关系，我们都可以看作是一条有向边，每个灯就是图上的每个节点。</p><p>仔细一想，构成的图就是一个基环树森林（多个基环树）。</p><p>我们用拓扑排序跑一遍，遇到开着的灯就关，就可以只留下多个环。</p><p>而在环上模拟关灯的话，只要考虑1的个数的奇偶性就行了。因为我们可以发现：开关操作要么1不变、要么多两个1，要么少2个1，1的个数的奇偶性是不变的。如果是偶数个灯，就一定有办法变为只剩0个灯；反之，如果是奇数，就一定不行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pdd pair<span class="string">&lt;double, double&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pll pair<span class="string">&lt;ll, ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n<span class="number">+1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">fa</span><span class="params">(n<span class="number">+1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        fa[i] = i;</span><br><span class="line">    function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; find = [&amp;](<span class="type">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">if</span>(x == fa[x]) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">return</span> fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">deg</span><span class="params">(n<span class="number">+1</span>)</span>, <span class="title">p</span><span class="params">(n<span class="number">+1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; p[i];</span><br><span class="line">        <span class="type">int</span> u = <span class="built_in">find</span>(i);</span><br><span class="line">        <span class="type">int</span> v = <span class="built_in">find</span>(p[i]);</span><br><span class="line">        <span class="keyword">if</span>(u != v) fa[u] = v;</span><br><span class="line">        deg[p[i]] ++;</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    <span class="keyword">if</span>(deg[i] == <span class="number">0</span>) &#123;</span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> i = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(a[i]) &#123;</span><br><span class="line">            a[p[i]] = <span class="number">1</span>-a[p[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        deg[p[i]] --;</span><br><span class="line">        <span class="keyword">if</span>(deg[p[i]] == <span class="number">0</span>) q.<span class="built_in">push</span>(p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(n<span class="number">+1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    <span class="keyword">if</span>(deg[i] &amp;&amp; a[i] == <span class="number">1</span>) &#123;</span><br><span class="line">        cnt[<span class="built_in">find</span>(i)] ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    <span class="keyword">if</span>(cnt[i] % <span class="number">2</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">10</span>);</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Felix大佬的验题代码思路更清晰、也更直观，还有生动的注释，推荐大家学习一下orz。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="comment">// 并不是……哇靠，原来是，拓扑排序！！硬生生想复杂了呜呜呜呜呜呜呜呜呜</span></span><br><span class="line"><span class="type">int</span> p[<span class="number">100005</span>], n, a[<span class="number">100005</span>], in_degree[<span class="number">100005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check_cycle</span><span class="params">(<span class="type">int</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> light = a[start]; <span class="comment">//环上有几个灯开着</span></span><br><span class="line">    in_degree[start] = <span class="number">0</span>; <span class="comment">//把环从世界上抹去！！F**k 环！！</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = p[start]; i != start; i = p[i])</span><br><span class="line">    &#123;</span><br><span class="line">        in_degree[i] = <span class="number">0</span>;</span><br><span class="line">        light += a[i];</span><br><span class="line">        a[i] = <span class="number">0</span>; <span class="comment">//环里的都给我关了！！</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> light % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">toposhin_start</span><span class="params">(queue&lt;<span class="type">int</span>&gt; &amp;q)</span> <span class="comment">//拓扑神，启动！</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> now = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(a[now] == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            a[now] = <span class="number">0</span>;</span><br><span class="line">            a[p[now]] = !a[p[now]];;</span><br><span class="line">        &#125;</span><br><span class="line">        in_degree[p[now]] --;</span><br><span class="line">        <span class="keyword">if</span>(in_degree[p[now]] == <span class="number">0</span>)</span><br><span class="line">            q.<span class="built_in">push</span>(p[now]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">memset</span>(in_degree, <span class="number">0</span>, <span class="built_in">sizeof</span>(in_degree));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; p[i];</span><br><span class="line">        in_degree[p[i]] ++;</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; starts;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(in_degree[i] == <span class="number">0</span>)</span><br><span class="line">            starts.<span class="built_in">push</span>(i);</span><br><span class="line">    <span class="built_in">toposhin_start</span>(starts); <span class="comment">//拓扑排序结束之后，就只剩下一个一个一个一个的环了</span></span><br><span class="line">    <span class="comment">//处理环</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(in_degree[i] == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">check_cycle</span>(i))</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;No&quot;</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Yes&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">11</span></span><br><span class="line"><span class="comment">1 0 1 0 1 0 0 0 1 1 0</span></span><br><span class="line"><span class="comment">2 3 4 1 6 7 8 9 7 7 7</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">15</span></span><br><span class="line"><span class="comment">1 1 1 1 1 1 1 1 1 1 1 1 1 1 1</span></span><br><span class="line"><span class="comment">2 3 4 5 6 7 1 13 14 13 14 13 14 1 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">11</span></span><br><span class="line"><span class="comment">1 1 0 1 0 1 1 1 1 1 0</span></span><br><span class="line"><span class="comment">2 3 11 5 3 3 3 3 8 9 10</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="做法二-2"><a class="markdownIt-Anchor" href="#做法二-2"></a> 做法二</h2><p>【并查集】<br />但仔细一想，我们发现基环树枝叶上的1总会收束到环上；同时，在收束到环之后，1的个数的奇偶性和收束前也一定是一样的。<br />所以其实拓扑排序这一步是多余的，我们只需要统计初始状态下每个连通块中1的个数即可。</p><p>若出现某一个连通块中1的个数是奇数，就一定无法全关。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pdd pair<span class="string">&lt;double, double&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pll pair<span class="string">&lt;ll, ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n<span class="number">+1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">fa</span><span class="params">(n<span class="number">+1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        fa[i] = i;</span><br><span class="line">    function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; find = [&amp;](<span class="type">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">if</span>(x == fa[x]) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">return</span> fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">deg</span><span class="params">(n<span class="number">+1</span>)</span>, <span class="title">p</span><span class="params">(n<span class="number">+1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; p[i];</span><br><span class="line">        <span class="type">int</span> u = <span class="built_in">find</span>(i);</span><br><span class="line">        <span class="type">int</span> v = <span class="built_in">find</span>(p[i]);</span><br><span class="line">        <span class="keyword">if</span>(u != v) fa[u] = v;</span><br><span class="line">        deg[p[i]] ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(n<span class="number">+1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    <span class="keyword">if</span>(a[i] == <span class="number">1</span>) &#123;</span><br><span class="line">        cnt[<span class="built_in">find</span>(i)] ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    <span class="keyword">if</span>(cnt[i] % <span class="number">2</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>PS：这题也可以用强连通分量缩点来写，本质和并查集做法差不多，就是更暴力一点。<br />我个人觉得没必要那样，想学习的同学可以私我要代码。</p></blockquote><h1 id="g-帮lihg开灯"><a class="markdownIt-Anchor" href="#g-帮lihg开灯"></a> G 帮Lihg开灯</h1><p>【树状数组】【DFS序】</p><p>树状数组+DFN序模板题，想补题的同学，学习一下这两个知识点就行了。</p><p>学会了之后，使用这个工具模拟即可！</p><blockquote><p>一个有意思的事：这道题和刚刚结束的3月31日的CSP认证的最后一题知识点撞了，那道题是这道题的一个加强版</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pdd pair<span class="string">&lt;double, double&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pll pair<span class="string">&lt;ll, ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fenwick</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    vector&lt;T&gt; tr;</span><br><span class="line">    <span class="built_in">Fenwick</span>(<span class="type">int</span> n) : <span class="built_in">n</span>(n), <span class="built_in">tr</span>(n + <span class="number">1</span>, <span class="number">0</span>)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, T c)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = x; i &lt;= n; i += <span class="built_in">lowbit</span>(i)) tr[i] += c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">sum</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        T res = <span class="built_in">T</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = x; i; i -= <span class="built_in">lowbit</span>(i)) res += tr[i];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">sum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(r) - <span class="built_in">sum</span>(l - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; g[n<span class="number">+1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        g[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        g[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(n<span class="number">+5</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        cin &gt;&gt; a;</span><br><span class="line">        p[a] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dfn</span><span class="params">(n<span class="number">+5</span>)</span>, <span class="title">sz</span><span class="params">(n<span class="number">+5</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> u, <span class="type">int</span> fa) &#123;</span><br><span class="line">        dfn[u] = ++cnt;</span><br><span class="line">        sz[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v: g[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(v == fa) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(v, u);</span><br><span class="line">            sz[u] += sz[v];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="function">Fenwick&lt;<span class="type">int</span>&gt; <span class="title">bit</span><span class="params">(n<span class="number">+5</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n<span class="number">+1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        bit.<span class="built_in">add</span>(dfn[p[i]], <span class="number">1</span>);</span><br><span class="line">        res[p[i]] = bit.<span class="built_in">sum</span>(dfn[p[i]], dfn[p[i]]+sz[p[i]]<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        cout &lt;&lt; res[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="h-能量之地"><a class="markdownIt-Anchor" href="#h-能量之地"></a> H 能量之地</h1><p>【模拟】</p><h2 id="做法一-3"><a class="markdownIt-Anchor" href="#做法一-3"></a> 做法一</h2><p>这道题主要有两个做法，一种做法就是老老实实地模拟蛇形走位的过程。用一个变量来维护，向左还是向右。应该是比较简洁的形式了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pdd pair<span class="string">&lt;double, double&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pll pair<span class="string">&lt;ll, ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">a</span>(n<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m<span class="number">+1</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=m; j++)</span><br><span class="line">        cin &gt;&gt; a[i][j];</span><br><span class="line">    <span class="type">int</span> x=<span class="number">1</span>, y=<span class="number">1</span>, tot=<span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> p = <span class="literal">false</span>;</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123; <span class="comment">// 永真循环</span></span><br><span class="line">        sum += <span class="number">1ll</span>*a[x][y];</span><br><span class="line">        <span class="keyword">if</span>(x == n &amp;&amp; y == m) <span class="keyword">break</span>; <span class="comment">// 走到(n, m)就退出循环</span></span><br><span class="line">        <span class="keyword">if</span>(y == m &amp;&amp; tot%<span class="number">2</span> == <span class="number">0</span> || y == <span class="number">1</span> &amp;&amp; tot%<span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            x ++;</span><br><span class="line">            <span class="keyword">if</span>(p) p = <span class="literal">false</span>, tot ++;</span><br><span class="line">            <span class="keyword">else</span> p = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(tot % <span class="number">2</span> == <span class="number">0</span>) y ++;</span><br><span class="line">            <span class="keyword">else</span> y --;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="做法二-3"><a class="markdownIt-Anchor" href="#做法二-3"></a> 做法二</h2><p>另一种做法是以一行为单位算总共分行号%4=0,1,2,3有4种情况但这个做法需要处理的边界条件比较多，验题的时候不少验题人用这个做法贡献了几发wa，所以推荐使用第一种做法。<br />这里附上本题主角Catgok的验题代码！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">9</span>, INF = <span class="number">1e18</span> + <span class="number">9</span>, P = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> T, n, m, x;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>) ans += x;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i % <span class="number">4</span> == <span class="number">1</span> &amp;&amp; j == m - <span class="number">1</span>) ans += x;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i % <span class="number">4</span> == <span class="number">3</span> &amp;&amp; j == <span class="number">0</span>) ans += x;</span><br><span class="line">            <span class="keyword">if</span>(i == n - <span class="number">1</span> &amp;&amp; i % <span class="number">4</span> == <span class="number">2</span> &amp;&amp; j != m - <span class="number">1</span>) ans -= x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// cin &gt;&gt; t;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(t--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="i-轮回与更迭"><a class="markdownIt-Anchor" href="#i-轮回与更迭"></a> I 轮回与更迭</h1><p>【思维】【模拟】<br />本题有两个操作：①改变值；②左移</p><p>我们不难发现，每一行是独立的，与其他行没有关系。</p><p>再者，对于all可行方案，先左移完了再改变，一定是最省事的！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pdd pair<span class="string">&lt;double, double&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pll pair<span class="string">&lt;ll, ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">a</span>(n<span class="number">+1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m<span class="number">+5</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=m; j++) &#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            x -= (i<span class="number">-1</span>)*m;</span><br><span class="line">            a[i][j] = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(m)</span></span>; <span class="comment">//cnt表示左移i次之后，为达成条件需要改变的数的个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=m; j++) &#123; </span><br><span class="line">            <span class="keyword">if</span>(a[i][j] &lt; <span class="number">1</span> || a[i][j] &gt; m) <span class="keyword">continue</span>;</span><br><span class="line">            cnt[(j-a[i][j]+m) % m] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> minn = <span class="number">1e9</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;m; i++)</span><br><span class="line">            minn = <span class="built_in">min</span>(minn, i+m-cnt[i]);</span><br><span class="line">        res += minn;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 比赛题解 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
